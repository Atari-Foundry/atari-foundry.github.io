{"pageProps":{"product":"crucible","productDocs":{"product":"crucible","files":[{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/README.md","relativePath":"README.md","relativeDir":"","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","relativePath":"API_REFERENCE.md","relativeDir":"","filename":"API_REFERENCE","slug":"api-reference","name":"API REFERENCE"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ARCHITECTURE.md","relativePath":"ARCHITECTURE.md","relativeDir":"","filename":"ARCHITECTURE","slug":"architecture","name":"ARCHITECTURE"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ATTRIBUTIONS.md","relativePath":"ATTRIBUTIONS.md","relativeDir":"","filename":"ATTRIBUTIONS","slug":"attributions","name":"ATTRIBUTIONS"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/BUILDING.md","relativePath":"BUILDING.md","relativeDir":"","filename":"BUILDING","slug":"building","name":"BUILDING"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/CHANGELOG.md","relativePath":"CHANGELOG.md","relativeDir":"","filename":"CHANGELOG","slug":"changelog","name":"CHANGELOG"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/USER_GUIDE.md","relativePath":"USER_GUIDE.md","relativeDir":"","filename":"USER_GUIDE","slug":"user-guide","name":"USER GUIDE"}],"navTree":{"_files":[{"name":"README","slug":"readme","path":"README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/README.md","isIndex":true},{"name":"API REFERENCE","slug":"api-reference","path":"API_REFERENCE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","isIndex":false},{"name":"ARCHITECTURE","slug":"architecture","path":"ARCHITECTURE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ARCHITECTURE.md","isIndex":false},{"name":"ATTRIBUTIONS","slug":"attributions","path":"ATTRIBUTIONS.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ATTRIBUTIONS.md","isIndex":false},{"name":"BUILDING","slug":"building","path":"BUILDING.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/BUILDING.md","isIndex":false},{"name":"CHANGELOG","slug":"changelog","path":"CHANGELOG.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/CHANGELOG.md","isIndex":false},{"name":"USER GUIDE","slug":"user-guide","path":"USER_GUIDE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/USER_GUIDE.md","isIndex":false}]}},"docFile":{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","relativePath":"API_REFERENCE.md","relativeDir":"","filename":"API_REFERENCE","slug":"api-reference","name":"API REFERENCE","content":"# Crucible API Reference\n\n## Table of Contents\n\n1. [Overview](#overview)\n2. [Core Simulator API (sim65)](#core-simulator-api-sim65)\n3. [Atari BIOS API](#atari-bios-api)\n4. [ATR Filesystem API](#atr-filesystem-api)\n5. [Host Filesystem API](#host-filesystem-api)\n6. [SIO API](#sio-api)\n7. [Callback System](#callback-system)\n8. [Data Structures](#data-structures)\n\n## Overview\n\nThis document provides a complete reference for the crucible API. The API is organized into several modules:\n\n- **sim65**: Core 6502 CPU simulator\n- **atari**: Atari BIOS emulation\n- **atrfs**: ATR filesystem access\n- **athost**: Host filesystem device\n- **atsio**: SIO and ATR image access\n\n## Core Simulator API (sim65)\n\n### Simulator Creation and Management\n\n#### `sim65 sim65_new(void)`\n\nCreates a new simulator instance.\n\n**Returns**: Simulator handle, or NULL on error\n\n**Example**:\n```c\nsim65 s = sim65_new();\nif (!s) {\n    fprintf(stderr, \"Failed to create simulator\\n\");\n    exit(1);\n}\n```\n\n#### `void sim65_free(sim65 s)`\n\nFrees a simulator instance and all associated memory.\n\n**Parameters**:\n- `s`: Simulator handle\n\n### Memory Management\n\n#### `void sim65_add_ram(sim65 s, unsigned addr, unsigned len)`\n\nAdds an uninitialized RAM region.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Length in bytes\n\n#### `void sim65_add_zeroed_ram(sim65 s, unsigned addr, unsigned len)`\n\nAdds a zeroed RAM region.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Length in bytes\n\n#### `void sim65_add_data_ram(sim65 s, unsigned addr, const unsigned char *data, unsigned len)`\n\nAdds a RAM region initialized with data.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `data`: Initial data\n- `len`: Length in bytes\n\n#### `void sim65_add_data_rom(sim65 s, unsigned addr, const unsigned char *data, unsigned len)`\n\nAdds a ROM region (read-only).\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `data`: ROM data\n- `len`: Length in bytes\n\n#### `unsigned sim65_get_byte(sim65 s, unsigned addr)`\n\nReads a byte from memory.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Memory address\n\n**Returns**: Byte value, or 0x100 if invalid/uninitialized\n\n### Execution Control\n\n#### `enum sim65_error sim65_run(sim65 s, struct sim65_reg *regs, unsigned addr)`\n\nRuns the simulation from the given address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Initial register values (NULL for zero)\n- `addr`: Starting address\n\n**Returns**: Error code (0 = success)\n\n**Example**:\n```c\nstruct sim65_reg regs = {0};\nregs.pc = 0x0600;\nenum sim65_error err = sim65_run(s, &regs, 0x0600);\n```\n\n#### `enum sim65_error sim65_call(sim65 s, struct sim65_reg *regs, unsigned addr)`\n\nCalls a subroutine via JSR and returns on RTS.\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Register values (NULL for zero)\n- `addr`: Subroutine address\n\n**Returns**: Error code (0 = success, `sim65_err_call_ret` = normal return)\n\n### Callbacks\n\n#### `void sim65_add_callback(sim65 s, unsigned addr, sim65_callback cb, enum sim65_cb_type type)`\n\nAdds a callback at a specific address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Address for callback\n- `cb`: Callback function\n- `type`: Callback type (read, write, or exec)\n\n**Callback Types**:\n- `sim65_cb_read`: Memory read callback\n- `sim65_cb_write`: Memory write callback\n- `sim65_cb_exec`: Instruction execution callback\n\n#### `void sim65_add_callback_range(sim65 s, unsigned addr, unsigned len, sim65_callback cb, enum sim65_cb_type type)`\n\nAdds callbacks for an address range.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Range length\n- `cb`: Callback function\n- `type`: Callback type\n\n### Debugging and Tracing\n\n#### `void sim65_set_debug(sim65 s, enum sim65_debug level)`\n\nSets debug output level.\n\n**Parameters**:\n- `s`: Simulator handle\n- `level`: Debug level (`sim65_debug_none`, `sim65_debug_messages`, `sim65_debug_trace`)\n\n#### `void sim65_set_trace_file(sim65 s, FILE *f)`\n\nSets trace output file.\n\n**Parameters**:\n- `s`: Simulator handle\n- `f`: File handle (NULL for stderr)\n\n#### `void sim65_set_error_level(sim65 s, enum sim65_error_lvl level)`\n\nSets error reporting level.\n\n**Parameters**:\n- `s`: Simulator handle\n- `level`: Error level (`sim65_errlvl_none`, `sim65_errlvl_memory`, `sim65_errlvl_full`)\n\n#### `int sim65_dprintf(sim65 s, const char *format, ...)`\n\nPrints debug message (if debug enabled).\n\n**Parameters**:\n- `s`: Simulator handle\n- `format`: printf-style format string\n- `...`: Format arguments\n\n#### `int sim65_eprintf(sim65 s, const char *format, ...)`\n\nPrints error message (always).\n\n**Parameters**:\n- `s`: Simulator handle\n- `format`: printf-style format string\n- `...`: Format arguments\n\n### Profiling\n\n#### `void sim65_set_profiling(sim65 s, int enable)`\n\nEnables or disables profiling.\n\n**Parameters**:\n- `s`: Simulator handle\n- `enable`: Non-zero to enable\n\n#### `struct sim65_profile sim65_get_profile_info(sim65 s)`\n\nGets profiling information.\n\n**Returns**: Profile structure with cycle counts and statistics\n\n### Utility Functions\n\n#### `void sim65_set_flags(sim65 s, uint8_t flag, uint8_t val)`\n\nSets or clears processor flags.\n\n**Parameters**:\n- `s`: Simulator handle\n- `flag`: Flag mask (SIM65_FLAG_C, SIM65_FLAG_Z, etc.)\n- `val`: Value (0 = clear, non-zero = set)\n\n#### `void sim65_set_cycle_limit(sim65 s, uint64_t limit)`\n\nSets cycle execution limit.\n\n**Parameters**:\n- `s`: Simulator handle\n- `limit`: Maximum cycles (0 = unlimited)\n\n#### `void sim65_print_reg(const sim65 s, FILE *f)`\n\nPrints current register values.\n\n**Parameters**:\n- `s`: Simulator handle\n- `f`: Output file\n\n#### `const char *sim65_error_str(sim65 s, enum sim65_error e)`\n\nGets error message string.\n\n**Parameters**:\n- `s`: Simulator handle\n- `e`: Error code\n\n**Returns**: Error message string\n\n## Atari BIOS API\n\n### Initialization\n\n#### `void atari_init(sim65 s, emu_options *opts)`\n\nInitializes Atari BIOS emulation.\n\n**Parameters**:\n- `s`: Simulator handle\n- `opts`: Emulation options (NULL for defaults)\n\n**Options Structure**:\n```c\ntypedef struct {\n    int (*get_char)(void);  // Character input callback\n    void (*put_char)(int);  // Character output callback\n    int flags;              // Option flags\n} emu_options;\n```\n\n**Option Flags**:\n- `atari_opt_no_dos`: Skip DOS emulation\n- `atari_opt_pal`: PAL timing (50Hz)\n- `atari_opt_cycletime`: Cycle-based timing\n- `atari_opt_atari_mathpack`: Use original Atari math pack\n\n#### `int atari_add_option(emu_options *opt, const char *str)`\n\nParses option string and updates options.\n\n**Parameters**:\n- `opt`: Options structure\n- `str`: Option string (e.g., \"pal,fastmath\")\n\n**Returns**: 0 on success, non-zero on error\n\n### File Loading\n\n#### `enum sim65_error atari_xex_load(sim65 s, const char *name, int check)`\n\nLoads and runs a XEX file.\n\n**Parameters**:\n- `s`: Simulator handle\n- `name`: XEX filename\n- `check`: Non-zero to validate format\n\n**Returns**: Error code\n\n#### `enum sim65_error atari_rom_load(sim65 s, int addr, const char *name)`\n\nLoads a ROM file at the given address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Load address\n- `name`: ROM filename\n\n**Returns**: Error code\n\n#### `int atari_load_image(sim65 s, const char *file_name)`\n\nLoads an ATR disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `file_name`: ATR filename\n\n**Returns**: 0 on success, non-zero on error\n\n#### `enum sim65_error atari_boot_image(sim65 s)`\n\nBoots from a loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Error code\n\n### DOS Configuration\n\n#### `void atari_dos_set_root(sim65 s, const char *path)`\n\nSets root path for D: device.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: Root directory path (NULL for current directory)\n\n#### `void atari_dos_add_cmdline(sim65 s, const char *cmd)`\n\nAdds command-line argument to DOS.\n\n**Parameters**:\n- `s`: Simulator handle\n- `cmd`: Command-line string\n\n### Utility Functions\n\n#### `void add_rts_callback(sim65 s, unsigned addr, unsigned len, sim65_callback cb)`\n\nInstalls callback with RTS instruction.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Callback address\n- `len`: Range length\n- `cb`: Callback function\n\n#### `int atari_get_flags(sim65 s)`\n\nGets current emulation flags.\n\n**Returns**: Flags value\n\n## ATR Filesystem API\n\n### File Operations\n\n#### `int atrfs_find_file(sim65 s, const char *path, struct atr_dir_entry *entry)`\n\nFinds a file in the ATR filesystem.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: File path (e.g., \"FILE.EXT\" or \"DIR\\FILE.EXT\")\n- `entry`: Output directory entry\n\n**Returns**: 0 on success, -1 on error\n\n**Example**:\n```c\nstruct atr_dir_entry entry;\nif (atrfs_find_file(s, \"MYFILE.TXT\", &entry) == 0) {\n    printf(\"Found file: %s\\n\", entry.filename);\n}\n```\n\n#### `struct atr_file_handle *atrfs_open_file(sim65 s, uint16_t start_sector, uint32_t size)`\n\nOpens a file handle for reading.\n\n**Parameters**:\n- `s`: Simulator handle\n- `start_sector`: Starting sector number\n- `size`: File size in bytes\n\n**Returns**: File handle, or NULL on error\n\n#### `int atrfs_read_byte(struct atr_file_handle *fh)`\n\nReads a byte from file.\n\n**Parameters**:\n- `fh`: File handle\n\n**Returns**: Byte value, or -1 on EOF/error\n\n#### `int atrfs_seek(struct atr_file_handle *fh, uint32_t position)`\n\nSeeks to position in file.\n\n**Parameters**:\n- `fh`: File handle\n- `position`: Byte position\n\n**Returns**: 0 on success, -1 on error\n\n#### `void atrfs_close_file(struct atr_file_handle *fh)`\n\nCloses and frees file handle.\n\n**Parameters**:\n- `fh`: File handle\n\n### Directory Operations\n\n#### `int atrfs_read_directory(sim65 s, uint16_t dir_sector, struct atr_dir_entry *entries, int max_entries)`\n\nReads directory entries.\n\n**Parameters**:\n- `s`: Simulator handle\n- `dir_sector`: Directory sector number\n- `entries`: Output array\n- `max_entries`: Maximum entries to read\n\n**Returns**: Number of entries read, or -1 on error\n\n## Host Filesystem API\n\n### Initialization\n\n#### `void atari_host_init(sim65 s)`\n\nInitializes H: device handler.\n\n**Parameters**:\n- `s`: Simulator handle\n\n#### `void atari_host_set_root(sim65 s, const char *path)`\n\nSets root path for H: device.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: Root directory path (NULL for current directory)\n\n**Example**:\n```c\natari_host_init(s);\natari_host_set_root(s, \"/home/user/atari_files\");\n```\n\n## SIO API\n\n### Initialization\n\n#### `void atari_sio_init(sim65 s)`\n\nInitializes SIO emulation.\n\n**Parameters**:\n- `s`: Simulator handle\n\n### Disk Image Operations\n\n#### `int atari_sio_load_image(sim65 s, const char *file_name)`\n\nLoads an ATR disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `file_name`: ATR filename\n\n**Returns**: 0 on success, non-zero on error\n\n#### `enum sim65_error atari_sio_boot(sim65 s)`\n\nBoots from loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Error code\n\n### ATR Access\n\n#### `const struct atr_disk_image *atari_sio_get_disk_image(sim65 s)`\n\nGets pointer to loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Disk image structure, or NULL if not loaded\n\n#### `int atari_sio_read_sector(sim65 s, unsigned sector, uint8_t *buffer, unsigned *size)`\n\nReads a sector from ATR image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `sector`: Sector number (1-based)\n- `buffer`: Output buffer\n- `size`: Input/output buffer size\n\n**Returns**: 0 on success, non-zero on error\n\n## Callback System\n\n### Callback Function Signature\n\n```c\ntypedef int (*sim65_callback)(sim65 s, struct sim65_reg *regs, \n                               unsigned addr, int data);\n```\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Register values before instruction\n- `addr`: Address causing callback\n- `data`: \n  - For read callbacks: unused\n  - For write callbacks: value being written\n  - For exec callbacks: `sim65_cb_exec`\n\n**Returns**:\n- For read callbacks: byte value (0-255)\n- For other callbacks: error code (0 = success, negative = error)\n\n### Example Callback\n\n```c\nstatic int my_callback(sim65 s, struct sim65_reg *regs, \n                       unsigned addr, int data)\n{\n    if (data == sim65_cb_exec) {\n        // Instruction execution callback\n        sim65_dprintf(s, \"Executing at $%04X\\n\", addr);\n        // Simulate RTS if needed\n        return 0;\n    }\n    return 0;\n}\n\n// Register callback\nsim65_add_callback(s, 0xE456, my_callback, sim65_cb_exec);\n```\n\n## Data Structures\n\n### `struct sim65_reg`\n\nCPU register values.\n\n```c\nstruct sim65_reg {\n    uint16_t pc;  // Program counter\n    uint8_t a;    // Accumulator\n    uint8_t x;    // X register\n    uint8_t y;    // Y register\n    uint8_t p;    // Processor status\n    uint8_t s;    // Stack pointer\n};\n```\n\n### `struct atr_file_handle`\n\nATR file handle.\n\n```c\nstruct atr_file_handle {\n    uint16_t start_sector;\n    uint16_t current_sector;\n    uint32_t file_size;\n    uint32_t position;\n    uint8_t sector_buffer[256];\n    int sector_pos;\n    int sector_size;\n    sim65 sim;\n};\n```\n\n### `struct atr_dir_entry`\n\nATR directory entry.\n\n```c\nstruct atr_dir_entry {\n    uint8_t flags;\n    uint16_t start_sector;\n    uint16_t sector_count;\n    uint32_t byte_count;\n    char filename[12];\n    uint8_t attributes;\n    int is_hidden;\n    int is_protected;\n    int is_archived;\n};\n```\n\n### `struct atr_disk_image`\n\nATR disk image structure.\n\n```c\nstruct atr_disk_image {\n    uint8_t *data;\n    unsigned sec_size;\n    unsigned sec_count;\n};\n```\n\n### `enum sim65_error`\n\nError codes.\n\n```c\nenum sim65_error {\n    sim65_err_none = 0,\n    sim65_err_exec_undef = -1,\n    sim65_err_exec_uninit = -2,\n    sim65_err_read_undef = -3,\n    sim65_err_read_uninit = -4,\n    sim65_err_write_undef = -5,\n    sim65_err_write_rom = -6,\n    sim65_err_break = -7,\n    sim65_err_invalid_ins = -8,\n    sim65_err_call_ret = -9,\n    sim65_err_cycle_limit = -10,\n    sim65_err_user = -11\n};\n```\n\n## Error Handling\n\nAll functions that can fail return error codes. Check return values:\n\n```c\nenum sim65_error err = atari_xex_load(s, \"program.xex\", 1);\nif (err != sim65_err_none) {\n    fprintf(stderr, \"Error: %s\\n\", sim65_error_str(s, err));\n}\n```\n\n## Memory Management\n\n- Simulator handles memory allocation internally\n- File handles must be closed with `atrfs_close_file()`\n- Simulator instance must be freed with `sim65_free()`\n\n## Thread Safety\n\nThe API is **not** thread-safe. Use one simulator instance per thread.\n\n## See Also\n\n- [User Guide](USER_GUIDE.md) - Usage examples\n- [Architecture](ARCHITECTURE.md) - System design\n- [Building Guide](BUILDING.md) - Build instructions\n"},"currentPath":"api-reference"},"__N_SSG":true}