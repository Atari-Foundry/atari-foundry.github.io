{"pageProps":{"product":"forge","productDocs":{"product":"forge","files":[{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/cc65/README.md","relativePath":"cc65/README.md","relativeDir":"cc65","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/README.md","relativePath":"README.md","relativeDir":"","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/attributions.md","relativePath":"about/attributions.md","relativeDir":"about","filename":"attributions","slug":"attributions","name":"attributions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/cio-reference.md","relativePath":"advanced-topics/cio-reference.md","relativeDir":"advanced-topics","filename":"cio-reference","slug":"cio-reference","name":"cio-reference"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/compiling.md","relativePath":"getting-started/compiling.md","relativeDir":"getting-started","filename":"compiling","slug":"compiling","name":"compiling"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/differences.md","relativePath":"getting-started/differences.md","relativeDir":"getting-started","filename":"differences","slug":"differences","name":"differences"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/display-list-interrupts.md","relativePath":"advanced-topics/display-list-interrupts.md","relativeDir":"advanced-topics","filename":"display-list-interrupts","slug":"display-list-interrupts","name":"display-list-interrupts"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-guide.md","relativePath":"editor/editor-guide.md","relativeDir":"editor","filename":"editor-guide","slug":"editor-guide","name":"editor-guide"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-optimization.md","relativePath":"editor/editor-optimization.md","relativeDir":"editor","filename":"editor-optimization","slug":"editor-optimization","name":"editor-optimization"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/expressions.md","relativePath":"language-reference/expressions.md","relativeDir":"language-reference","filename":"expressions","slug":"expressions","name":"expressions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/first-steps.md","relativePath":"getting-started/first-steps.md","relativeDir":"getting-started","filename":"first-steps","slug":"first-steps","name":"first-steps"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/fujinet.md","relativePath":"advanced-topics/fujinet.md","relativeDir":"advanced-topics","filename":"fujinet","slug":"fujinet","name":"fujinet"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/functions.md","relativePath":"language-reference/functions.md","relativeDir":"language-reference","filename":"functions","slug":"functions","name":"functions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/hardware-registers.md","relativePath":"reference/hardware-registers.md","relativeDir":"reference","filename":"hardware-registers","slug":"hardware-registers","name":"hardware-registers"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/index.md","relativePath":"index.md","relativeDir":"","filename":"index","slug":"index","name":"index"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/interrupts.md","relativePath":"reference/interrupts.md","relativeDir":"reference","filename":"interrupts","slug":"interrupts","name":"interrupts"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/introduction.md","relativePath":"getting-started/introduction.md","relativeDir":"getting-started","filename":"introduction","slug":"introduction","name":"introduction"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/iocb-structure.md","relativePath":"reference/iocb-structure.md","relativeDir":"reference","filename":"iocb-structure","slug":"iocb-structure","name":"iocb-structure"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/low-level-programming.md","relativePath":"advanced-topics/low-level-programming.md","relativeDir":"advanced-topics","filename":"low-level-programming","slug":"low-level-programming","name":"low-level-programming"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-map.md","relativePath":"reference/memory-map.md","relativeDir":"reference","filename":"memory-map","slug":"memory-map","name":"memory-map"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-usage.md","relativePath":"reference/memory-usage.md","relativeDir":"reference","filename":"memory-usage","slug":"memory-usage","name":"memory-usage"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/note-point.md","relativePath":"advanced-topics/note-point.md","relativeDir":"advanced-topics","filename":"note-point","slug":"note-point","name":"note-point"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/os-equates.md","relativePath":"reference/os-equates.md","relativeDir":"reference","filename":"os-equates","slug":"os-equates","name":"os-equates"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/r-handler.md","relativePath":"reference/r-handler.md","relativeDir":"reference","filename":"r-handler","slug":"r-handler","name":"r-handler"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/sio-operations.md","relativePath":"advanced-topics/sio-operations.md","relativeDir":"advanced-topics","filename":"sio-operations","slug":"sio-operations","name":"sio-operations"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/statements.md","relativePath":"language-reference/statements.md","relativeDir":"language-reference","filename":"statements","slug":"statements","name":"statements"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/syntax.md","relativePath":"language-reference/syntax.md","relativeDir":"language-reference","filename":"syntax","slug":"syntax","name":"syntax"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/why-forge.md","relativePath":"about/why-forge.md","relativeDir":"about","filename":"why-forge","slug":"why-forge","name":"why-forge"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/xio-reference.md","relativePath":"advanced-topics/xio-reference.md","relativeDir":"advanced-topics","filename":"xio-reference","slug":"xio-reference","name":"xio-reference"}],"navTree":{"cc65":{"_files":[{"name":"README","slug":"readme","path":"cc65/README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/cc65/README.md","isIndex":true}]},"_files":[{"name":"README","slug":"readme","path":"README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/README.md","isIndex":true},{"name":"index","slug":"index","path":"index.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/index.md","isIndex":false}],"about":{"_files":[{"name":"attributions","slug":"attributions","path":"about/attributions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/attributions.md","isIndex":false},{"name":"why-forge","slug":"why-forge","path":"about/why-forge.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/why-forge.md","isIndex":false}]},"advanced-topics":{"_files":[{"name":"cio-reference","slug":"cio-reference","path":"advanced-topics/cio-reference.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/cio-reference.md","isIndex":false},{"name":"display-list-interrupts","slug":"display-list-interrupts","path":"advanced-topics/display-list-interrupts.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/display-list-interrupts.md","isIndex":false},{"name":"fujinet","slug":"fujinet","path":"advanced-topics/fujinet.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/fujinet.md","isIndex":false},{"name":"low-level-programming","slug":"low-level-programming","path":"advanced-topics/low-level-programming.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/low-level-programming.md","isIndex":false},{"name":"note-point","slug":"note-point","path":"advanced-topics/note-point.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/note-point.md","isIndex":false},{"name":"sio-operations","slug":"sio-operations","path":"advanced-topics/sio-operations.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/sio-operations.md","isIndex":false},{"name":"xio-reference","slug":"xio-reference","path":"advanced-topics/xio-reference.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/xio-reference.md","isIndex":false}]},"getting-started":{"_files":[{"name":"compiling","slug":"compiling","path":"getting-started/compiling.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/compiling.md","isIndex":false},{"name":"differences","slug":"differences","path":"getting-started/differences.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/differences.md","isIndex":false},{"name":"first-steps","slug":"first-steps","path":"getting-started/first-steps.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/first-steps.md","isIndex":false},{"name":"introduction","slug":"introduction","path":"getting-started/introduction.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/introduction.md","isIndex":false}]},"editor":{"_files":[{"name":"editor-guide","slug":"editor-guide","path":"editor/editor-guide.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-guide.md","isIndex":false},{"name":"editor-optimization","slug":"editor-optimization","path":"editor/editor-optimization.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-optimization.md","isIndex":false}]},"language-reference":{"_files":[{"name":"expressions","slug":"expressions","path":"language-reference/expressions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/expressions.md","isIndex":false},{"name":"functions","slug":"functions","path":"language-reference/functions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/functions.md","isIndex":false},{"name":"statements","slug":"statements","path":"language-reference/statements.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/statements.md","isIndex":false},{"name":"syntax","slug":"syntax","path":"language-reference/syntax.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/syntax.md","isIndex":false}]},"reference":{"_files":[{"name":"hardware-registers","slug":"hardware-registers","path":"reference/hardware-registers.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/hardware-registers.md","isIndex":false},{"name":"interrupts","slug":"interrupts","path":"reference/interrupts.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/interrupts.md","isIndex":false},{"name":"iocb-structure","slug":"iocb-structure","path":"reference/iocb-structure.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/iocb-structure.md","isIndex":false},{"name":"memory-map","slug":"memory-map","path":"reference/memory-map.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-map.md","isIndex":false},{"name":"memory-usage","slug":"memory-usage","path":"reference/memory-usage.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-usage.md","isIndex":false},{"name":"os-equates","slug":"os-equates","path":"reference/os-equates.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/os-equates.md","isIndex":false},{"name":"r-handler","slug":"r-handler","path":"reference/r-handler.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/r-handler.md","isIndex":false}]}}},"docFile":{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/functions.md","relativePath":"language-reference/functions.md","relativeDir":"language-reference","filename":"functions","slug":"functions","name":"functions","content":"# Functions\n\nFunctions take parameters (normally between parentheses) and return a result.\n\n## Function Syntax\n\n### Abbreviations\n\nFunctions can be abbreviated by using a shorter name ended in a dot, for example you can write `R.(10)` instead of `RAND(10)`.\n\n### Parentheses\n\nYou can also omit parentheses on functions that take only one argument, for example, `RAND 10`.\n\n**Note:** This is not possible when the function accepts a variable number of arguments (as with `USR`), or with the `ADR` function.\n\n### Parameterless Functions\n\nSome functions don't take parameters, and you must provide a set of parentheses, like `KEY()`. However, when abbreviated, you can omit the parenthesis, like `K.` for `KEY()`.\n\n## Standard Functions\n\nFollowing is a list of all the general purpose functions supported by FORGE. Shown are the full syntax and the abbreviated syntax.\n\n### TIME / T.\n\nReturns the current time in \"jiffies.\" This is about 60 times per second in NTSC systems or 50 times per second in PAL systems. Use `TIMER` statement to reset to 0.\n\nRemember that this function returns an integer, so the maximum value is 32767, or about 9 minutes in NTSC, and a little less than 11 minutes in PAL, after this the value will become negative. If you need to measure more than this amount, consider using the floating-point version `%TIME`.\n\n**Note:** `TIME` is special, and does not need parentheses.\n\n**Example:**\n```basic\nTIMER\nREPEAT\n  ? TIME\n  PAUSE 60\nUNTIL TIME > 300\n```\n\n### ABS(_num_) / A.(_num_)\n\nReturns the absolute value of _num_ (e.g., `ABS(5)` and `ABS(-5)` both result in `5`). Can be used with integers and floating point.\n\n**Example:**\n```basic\n? ABS(-10)  ' Prints 10\n? ABS(10)   ' Prints 10\n```\n\n### SGN(_num_) / SG.(_num_)\n\nReturns the sign of _num_, this is 1 if positive, -1 if negative or 0 if _num_ is 0. Can be used with integers and floating point.\n\n**Example:**\n```basic\n? SGN(10)   ' Prints 1\n? SGN(-5)   ' Prints -1\n? SGN(0)    ' Prints 0\n```\n\n### RAND(_num_) / R.(_num_)\n\nReturns a random, non negative number, a maximum of 1 less than _num_. (e.g., `RAND(3)` will result in 0, 1, or 2.)\n\n**See also:** `RND()` for floating point random numbers.\n\n**Example:**\n```basic\nDICE = RAND(6) + 1  ' Random number 1-6\n```\n\n### FRE() / F.\n\nReturns the free memory available in bytes.\n\n**Example:**\n```basic\n? \"Free memory: \"; FRE(); \" bytes\"\n```\n\n### ERR() / E.\n\nReturns the last Input/Output error value, or 1 if no error was registered.\n\n**Example:**\n```basic\nOPEN #1, 4, 0, \"D:FILE.TXT\"\nIF ERR() <> 1 THEN\n  ? \"Error opening file: \"; ERR()\nENDIF\n```\n\n### LEN(*string*) / L.(*string*)\n\nReturns the length of the *string*.\n\n**Example:**\n```basic\nA$ = \"Hello\"\n? LEN(A$)  ' Prints 5\n```\n\n### VAL(*string*) / V.(*string*)\n\nConverts *string* to a number. If no conversion is possible, `ERR()` is set to 18. Can be used with integers and floating point.\n\n**Example:**\n```basic\nA$ = \"123\"\nN = VAL(A$)\n? N  ' Prints 123\n```\n\n### ASC(*string*) / AS.(*string*)\n\nReturns the ATASCII code of the first character of the *string*.\n\n**Example:**\n```basic\n? ASC(\"A\")  ' Prints 65\n```\n\n## Atari Specific Functions\n\nThe following functions allow interacting with the Atari hardware to read controller and keyboard input and to program with Player/Missile graphics.\n\n### PADDLE(_n_) / PA.(_n_)\n\nReturns the value of the PADDLE controller _n_.\n\n**Example:**\n```basic\nP0 = PADDLE(0)  ' Horizontal axis of paddle 0\nP1 = PADDLE(1)  ' Vertical axis of paddle 0\n```\n\n### PMADR(_n_) / PM.(_n_)\n\nReturns the address of the data for Player _n_ or the address of the Missiles with _n_ = -1.\n\n**Example:**\n```basic\nPMGRAPHICS 2\nADDR = PMADR(0)  ' Address of Player 0 data\n```\n\n### PTRIG(_n_) / PT.(_n_)\n\nReturns 0 if the PADDLE controller _n_ button is pressed, 1 otherwise.\n\n**Example:**\n```basic\nIF PTRIG(0) = 0 THEN ? \"Button pressed\"\n```\n\n### STICK(_n_) / S.(_n_)\n\nReturns the JOYSTICK controller _n_ position. `STICK(_n_)` values are:\n\n```\n10  14   6\n\n11  15   7\n\n 9  13   5\n```\n\n**Example:**\n```basic\nDIR = STICK(0)\nIF DIR = 14 THEN ? \"Up\"\nIF DIR = 13 THEN ? \"Down\"\n```\n\n### STRIG(_n_) / STR.(_n_)\n\nReturns 0 if JOYSTICK controller _n_ button is pressed, 1 otherwise.\n\n**Example:**\n```basic\nIF STRIG(0) = 0 THEN ? \"Fire!\"\n```\n\n### KEY() / K.\n\nReturns 0 if no key was pressed, or a key code. The returned value only goes to 0 after reading the key in the OS (via a `GET` or `POKE 764, 255` statement).\n\n**Hint:** The value returned is actually the same as `(PEEK(764) EXOR 255)`.\n\n**Example:**\n```basic\nPRINT \"Press keys, exit with ESC\"\nREPEAT\n  REPEAT : UNTIL KEY()\n  PRINT \"Key code: \"; KEY()\n  GET K\n  PRINT \"ATASCII code: \"; K\nUNTIL K=27\n```\n\n**Note:** Some keys on the Atari -- the console keys `START`, `SELECT`, and `OPTION`; modifiers `SHIFT` and `CONTROL`; and the `HELP`, `BREAK`, and `RESET` keys -- are not handled in the same way as the main keyboard, and cannot be read by `GET`.\n\n**Hints:**\n- The status of all three console keys may be read via the GTIA `CONSOL` register, `PEEK(53279)`.\n- Whether the `HELP` key is pressed can be detected via the POKEY `KBCODE` register, `PEEK(53769)`.\n- Whether either `SHIFT` key is pressed can be detected via the POKEY `SKCTL` register, `PEEK(53775)`.\n\n## R: Device Status Functions\n\nThe following functions provide easy access to status information for R: devices (Atari 850 Interface Module, R:Verter, BOB-Verter). These functions automatically call `STATUS` on the specified channel and return the requested information from the DVSTAT buffer.\n\nAll functions take a channel number as their parameter and return 0 if the STATUS call fails.\n\n### Checking Carrier Status\n\nTo check if carrier is active, use `(PEEK(747) AND 8) <> 0` after calling `STATUS`. This checks bit 3 of DVSTAT[1], which works with both Atari 850 and verter-style handlers.\n\n**Example:**\n```basic\nOPEN #1,12,0,\"R1:\"\nSTATUS #1, ST\nIF ST = 1 AND (PEEK(747) AND 8) <> 0 THEN\n  ? \"Connection active\"\nELSE\n  ? \"No carrier\"\nENDIF\n```\n\n### Error Bits\n\nTo get error bits, use `PEEK(746)` after calling `STATUS`. Each bit represents a different error condition (bit 7=framing, bit 6=overrun, bit 5=parity, bit 4=overflow, etc.).\n\n### Sense Byte\n\nTo get the sense byte, use `PEEK(747)` after calling `STATUS`. The meaning depends on whether concurrent mode is active.\n\n### Buffer Counts\n\nTo get buffer counts when concurrent mode is active, use `PEEK(747) + 256 * PEEK(748)` for input buffer count and `PEEK(749)` for output buffer count after calling `STATUS`.\n\n## Floating Point Functions\n\nThese functions use floating point values, and are only available in the floating point version.\n\nIn case of errors (such as logarithm or square root of negative numbers and overflow in the results), the functions will return an invalid value, and the `ERR()` function returns 3.\n\n### ATN(_n_) / AT.(_n_)\n\nArc-Tangent of _n_.\n\n**Example:**\n```basic\nANGLE = ATN(1.0)  ' Returns approximately PI/4\n```\n\n### COS(_n_) / CO.(_n_)\n\nCosine of _n_.\n\n**Example:**\n```basic\nV = COS(0)  ' Returns 1.0\n```\n\n### EXP(_n_)\n\nNatural exponentiation (e raised to _n_).\n\n**Example:**\n```basic\nV = EXP(1.0)  ' Returns approximately 2.718\n```\n\n### EXP10(_n_) / EX.(_n_)\n\nReturns ten raised to _n_.\n\n**Example:**\n```basic\nV = EXP10(2)  ' Returns 100.0\n```\n\n### INT(_num_) / I.(_num_)\n\nConverts the floating point number _num_ to the nearest integer from -32768 to 32767.\n\n**Example:**\n```basic\nN = INT(3.7)  ' Returns 4\nN = INT(-3.7) ' Returns -4\n```\n\n### LOG(_n_)\n\nNatural logarithm of _n_.\n\n**Example:**\n```basic\nV = LOG(2.718)  ' Returns approximately 1.0\n```\n\n### LOG10(_n_) / LO.(_n_)\n\nDecimal logarithm of _n_.\n\n**Example:**\n```basic\nV = LOG10(100)  ' Returns 2.0\n```\n\n### RND() / RN.\n\nReturns a random positive number strictly less than 1.\n\n**See also:** `RAND()` for integer random numbers.\n\n**Example:**\n```basic\nR = RND()  ' Random number 0.0 to 0.999...\n```\n\n### SIN(_n_) / SI.(_n_)\n\nSine of _n_.\n\n**Example:**\n```basic\nV = SIN(0)  ' Returns 0.0\n```\n\n### SQR(_n_) / SQ.(_n_)\n\nSquare root of _n_.\n\n**Example:**\n```basic\nV = SQR(16)  ' Returns 4.0\n```\n\n### %TIME / %T.\n\nThis is the same as the `TIME` integer function, but returning a 24 bit number that does not wrap until more than 3 days.\n\n**Note:** Don't use the `TIMER` statement if you are using this function, as the returned value will be invalid.\n\n**Example:**\n```basic\nTIMER\n? %TIME  ' 24-bit time value\n```\n\n## String Functions\n\n### STR$(_num_)\n\nReturns a string with a printable value for _num_. Can be used with integers and floating point.\n\n**Note:** This function can't be used at both sides of a comparison, as the resulting string is overwritten each time it is called.\n\n**Example:**\n```basic\nA$ = STR$(123)  ' A$ = \"123\"\nB$ = STR$(3.14) ' B$ = \"3.14\"\n```\n\n### CHR$(_num_)\n\nConverts _num_ to a one character string with the ATASCII value.\n\n**Example:**\n```basic\nA$ = CHR$(65)  ' A$ = \"A\"\n```\n\n## Low Level Functions\n\nThe following functions are called \"low level\" because they interact directly with the hardware. **Use with care!**\n\n### ADR(_arr_) / &_arr_\n\nReturns the address of the first element of _arr_ in memory. Following elements of the array occupy adjacent memory locations.\n\nInstead of `ADR(X)` you can simply type `&X`.\n\n**Example:**\n```basic\nDIM A(10)\nADDR = ADR(A)  ' or ADDR = &A\n```\n\n### ADR(_str_) / &_str_\n\nReturns the address of the _string_ in memory. The first memory location contains the length of the string, and following locations contain the string characters.\n\n**Note:** This differs from Atari BASIC and TurboBASIC XL, where the address returned points to the first character of the string.\n\n**Example:**\n```basic\nA$ = \"Hello\"\nADDR = ADR(A$)  ' Address of string structure\n```\n\n### ADR(_var_) / &_var_\n\nReturns the address of the _variable_ in memory.\n\n**Example:**\n```basic\nX = 100\nADDR = ADR(X)  ' Address of variable X\n```\n\n### DPEEK(_addr_) / D.(_addr_)\n\nReturns the value of memory location _addr_ and _addr_+1 as a 16 bit integer.\n\nThis is the same as doing `PEEK(_addr_)+PEEK(_addr_+1)*256`.\n\n**Example:**\n```basic\nV = DPEEK(560)  ' Read 16-bit value at address 560\n```\n\n### DVSTAT(_index_) / DVS.(_index_)\n\nReads a byte from the DVSTAT buffer (device status buffer at memory locations 746-749). The _index_ parameter must be 0, 1, 2, or 3, corresponding to DVSTAT[0] through DVSTAT[3].\n\nThis function is used to read device-specific status information after calling `STATUS` on a device channel. The meaning of each byte depends on the device handler:\n\n- `DVSTAT(0)` - Error bits (bitfield)\n- `DVSTAT(1)` - Sense byte or buffer count low byte\n- `DVSTAT(2)` - Buffer count high byte (usually 0)\n- `DVSTAT(3)` - Output buffer count\n\nFor R: devices (Atari 850, R:Verter, BOB-Verter), see the helper functions above for easier access to common status information.\n\n**Example:**\n```basic\nSTATUS #1, ST\nIF ST = 1 THEN\n  ERR_BITS = DVSTAT(0)\n  SENSE = DVSTAT(1)\nENDIF\n```\n\n### PEEK(_address_) / P.(_address_)\n\nReturns the value of memory location at _address_.\n\n**Example:**\n```basic\nV = PEEK(53279)  ' Read CONSOL register\n```\n\n### USR(_address_[,_num1_ ...])\n\nLow level function that calls the user supplied machine code subroutine at _address_.\n\nParameters are pushed to the CPU stack, with the LOW part pushed first, so the first PLA returns the HIGH part of the last parameter, and so on.\n\nThe value of `A` and `X` registers is used as a return value of the function, with `A` the low part and `X` the high part.\n\n**Example:**\n```basic\n' PLA / EOR $FF / TAX / PLA / EOR $FF / RTS\nDATA ml() byte = $68,$49,$FF,$AA,$68,$49,$FF,$60\nFOR i=0 TO 1000 STEP 100\n  ? i, USR(ADR(ml),i)\nNEXT i\n```\n\n### $(_addr_)\n\nReturns the string at memory address _addr_.\n\nThis is the inverse of `ADR()`, and can be used to create arbitrary strings in memory.\n\n**Example:**\n```basic\nDATA x() byte = 2, $41, $42\n? $( ADR(x) )  ' Prints \"AB\"\n```\n\nYou can also store string addresses to reuse later, using less memory than copying the full string:\n\n```basic\nx = ADR(\"Hello\")\n? $( x )  ' Prints \"Hello\"\n```\n\n### %(_n_)\n\nThis returns the floating-point value stored at memory address _n_.\n\nThis function is special, as it is possible to use it also at the left side of an assignment, to store a floating point into an address:\n\n```basic\n%(1536) = 0.1234\n? %(1536)  ' Prints 0.1234\n```\n\n## Function Reference Table\n\n| Function | Abbreviation | Type | Parameters | Description |\n|----------|--------------|------|------------|-------------|\n| TIME | T. | Integer | None | Current time in jiffies |\n| ABS | A. | Numeric | Number | Absolute value |\n| SGN | SG. | Numeric | Number | Sign (-1, 0, or 1) |\n| RAND | R. | Integer | Max | Random integer |\n| FRE | F. | Integer | None | Free memory in bytes |\n| ERR | E. | Integer | None | Last I/O error |\n| LEN | L. | Integer | String | String length |\n| VAL | V. | Numeric | String | Convert string to number |\n| ASC | AS. | Integer | String | ATASCII code of first char |\n| PADDLE | PA. | Integer | Controller # | Paddle value |\n| PMADR | PM. | Integer | Player # | Player/Missile address |\n| PTRIG | PT. | Integer | Controller # | Paddle trigger state |\n| STICK | S. | Integer | Controller # | Joystick position |\n| STRIG | STR. | Integer | Controller # | Joystick trigger state |\n| KEY | K. | Integer | None | Key code |\n| ATN | AT. | Float | Number | Arc-tangent |\n| COS | CO. | Float | Number | Cosine |\n| EXP | - | Float | Number | Natural exponent |\n| EXP10 | EX. | Float | Number | 10 raised to power |\n| INT | I. | Integer | Float | Convert to integer |\n| LOG | - | Float | Number | Natural logarithm |\n| LOG10 | LO. | Float | Number | Decimal logarithm |\n| RND | RN. | Float | None | Random 0.0-1.0 |\n| SIN | SI. | Float | Number | Sine |\n| SQR | SQ. | Float | Number | Square root |\n| %TIME | %T. | Integer | None | 24-bit time |\n| STR$ | - | String | Number | Convert to string |\n| CHR$ | - | String | Number | ATASCII to character |\n| ADR | & | Integer | Variable | Memory address |\n| DPEEK | D. | Integer | Address | Read 16-bit value |\n| DVSTAT | DVS. | Integer | Index | DVSTAT buffer byte |\n| PEEK | P. | Integer | Address | Read byte |\n| USR | - | Integer | Address, ... | Call machine code |\n| $ | - | String | Address | String at address |\n| % | - | Float | Address | Float at address |\n\n## Next Steps\n\n- [Statements](statements.md) - Complete statement reference\n- [Expressions](expressions.md) - Expression operators and types\n- [Low-Level Programming](../advanced-topics/low-level-programming.md) - Advanced memory operations\n"},"currentPath":"language-reference/functions"},"__N_SSG":true}