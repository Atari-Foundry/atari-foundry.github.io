<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">interrupts | forge Documentation | Atari Foundry</title><meta name="description" content="forge documentation: interrupts" data-next-head=""/><link rel="preload" href="/images/foundry_logo_50H.png" as="image" data-next-head=""/><link rel="preload" href="/_next/static/chunks/c81f129e50a5fd79.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/c81f129e50a5fd79.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/e8a4a4ae55bc5744.js" defer=""></script><script src="/_next/static/chunks/00dac80f236dcabb.js" defer=""></script><script src="/_next/static/chunks/44f6bc00d9aaf830.js" defer=""></script><script src="/_next/static/chunks/fd7cb30d70431a0f.js" defer=""></script><script src="/_next/static/chunks/turbopack-4769270d21ef6607.js" defer=""></script><script src="/_next/static/chunks/1b081b821847ed60.js" defer=""></script><script src="/_next/static/chunks/39b01aa8a3352426.js" defer=""></script><script src="/_next/static/chunks/b56fd671c61106a7.js" defer=""></script><script src="/_next/static/chunks/turbopack-ab1a8023ffca1f9c.js" defer=""></script><script src="/_next/static/uKcVMkypfjITnNYGcdC5l/_ssgManifest.js" defer=""></script><script src="/_next/static/uKcVMkypfjITnNYGcdC5l/_buildManifest.js" defer=""></script></head><body><div id="__next"><div class="crt"><div class="scanlines" aria-hidden="true"></div><div class="noise" aria-hidden="true"></div><nav class="nav"><a class="nav-brand" href="/"><img alt="Atari Foundry icon" width="72" height="50" decoding="async" data-nimg="1" style="color:transparent;height:40px;width:auto" src="/images/foundry_logo_50H.png"/><div><span class="nav-brand-title">Atari Foundry</span><span class="nav-brand-sub">Products for Atari 8-bit</span></div></a><ul class="nav-links"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about">About</a></li><li class="nav-item"><a class="nav-link" href="/vault">Vault</a></li><li class="nav-item has-children"><button type="button" class="nav-link nav-trigger active" aria-haspopup="true" aria-expanded="false">Docs</button><div class="nav-dropdown"><a class="nav-dropdown-link" href="/docs/crucible">Crucible</a><a class="nav-dropdown-link" href="/docs/atrforge">atrforge</a><a class="nav-dropdown-link" href="/docs/forge">FORGE</a></div></li><li class="nav-item"><a class="nav-link" href="/support">Support</a></li></ul></nav><header class="subhero"><p class="label">forge<!-- --> Documentation</p><h1 class="page-title">interrupts</h1></header><main><div class="docs-layout"><aside class="docs-sidebar"><nav class="docs-nav"><div class="docs-nav-section"><h3>Documentation</h3><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:0rem" href="/docs/forge/readme">README</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/forge/index">index</a></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">cc65</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/cc65">README</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">about</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/about/attributions">attributions</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/about/why-forge">why-forge</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">advanced topics</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/cio-reference">cio-reference</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/display-list-interrupts">display-list-interrupts</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/fujinet">fujinet</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/low-level-programming">low-level-programming</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/note-point">note-point</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/sio-operations">sio-operations</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/advanced-topics/xio-reference">xio-reference</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">getting started</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/getting-started/compiling">compiling</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/getting-started/differences">differences</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/getting-started/first-steps">first-steps</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/getting-started/introduction">introduction</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">editor</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/editor/editor-guide">editor-guide</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/editor/editor-optimization">editor-optimization</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">language reference</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/language-reference/expressions">expressions</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/language-reference/functions">functions</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/language-reference/statements">statements</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/language-reference/syntax">syntax</a></li></ul></div></li><li><div class="docs-nav-section" style="margin-top:0"><h4 style="font-size:0.75rem;text-transform:uppercase;letter-spacing:0.15em;color:rgba(255, 255, 255, 0.5);margin-bottom:0.6rem;font-weight:700;padding-left:0rem">reference</h4><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/hardware-registers">hardware-registers</a></li><li><a class="doc-link active" style="padding-left:1.2rem" href="/docs/forge/reference/interrupts">interrupts</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/iocb-structure">iocb-structure</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/memory-map">memory-map</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/memory-usage">memory-usage</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/os-equates">os-equates</a></li><li><a class="doc-link " style="padding-left:1.2rem" href="/docs/forge/reference/r-handler">r-handler</a></li></ul></div></li></ul></div></nav></aside><div class="docs-content"><div class="docs-body"><div class="doc-markdown"><h1>System Interrupts</h1>
<p>System interrupt documentation for the Atari 8-bit computers.</p>
<h2>Overview</h2>
<p>There are four types of interrupts which can occur with the 6502 microprocessor:</p>
<ol>
<li><strong>Chip reset</strong></li>
<li><strong>IRQ</strong> (interrupt request, maskable)</li>
<li><strong>NMI</strong> (non-maskable interrupt)</li>
<li><strong>Software interrupt</strong> (BRK instruction)</li>
</ol>
<h2>Chip Reset</h2>
<p>On the 400/800 the chip reset occurs only upon power-up and causes the computer to do a cold start. On later models, pressing [SYSTEM RESET] will cause a chip reset but the computer then does a warm start. On the 400/800, the [SYSTEM RESET] key generates a NMI interrupt.</p>
<h2>Cold Start</h2>
<p>This is a synopsis of the cold start routine:</p>
<ol>
<li>The warm start flag [$0008] is set to 0 (false)</li>
<li>If a cartridge slot contains a diagnostic cartridge, control is handed to the cartridge</li>
<li>The end of RAM is determined by trying to complement the first byte of each 4K block of memory</li>
<li>Hardware registers at $D000 - $D4FF (except $D100 - $D1FF) are cleared</li>
<li>RAM is cleared from $0008 to the top of RAM</li>
<li>The user program jump vector, DOSVEC [$000A] is set to point to the black board mode (Atari logo display mode in XL/XE models)</li>
<li>The screen margins are set to 2 and 39</li>
<li>Interrupt vectors are initialized</li>
<li>Bottom of free RAM pointer, MEMLO [$02E7], is set to point to $0700</li>
<li>Resident CIO handlers are initialized</li>
<li>If the [START] key is pressed the cassette boot request flag, CKEY [$004A], is set</li>
<li>The CIO device table is initialized</li>
<li>If a cartridge is present it is initialized</li>
<li>Channel 0 is opened to the screen editor. The top-of-free-RAM pointer, MEMTOP [$02E5], is set to point below the screen region</li>
<li>If the cassette boot flag is set the cassette is booted</li>
<li>If there is no cartridge present or a cartridge doesn&#x27;t prevent it, the disk is booted</li>
<li>The cold start flag is reset</li>
<li>If there is a cartridge present, the computer jumps to the cartridge&#x27;s run vector</li>
<li>If there is no cartridge present the computer jumps through the vector DOSVEC [$000A (10)]</li>
</ol>
<h2>Warm Start</h2>
<ol>
<li>The warm start flag is set to $7F (true)</li>
<li>Cold start steps 2 - 4 are executed</li>
<li>RAM is cleared from $0010 - $007F and $0200 - $03FF</li>
<li>Cold start steps 7 - 14 are executed</li>
<li>If cassette booted software is present the computer JSRs through CASINI [$0002]</li>
<li>If disk booted software is present the computer JSRs through DOSINI [$000C (12)]</li>
</ol>
<p>The difference between cold start and warm start is the condition of the warm start flag, WARMST, [$0008]. If this flag is 0 a complete cold start is executed. If the flag is anything other than 0 then only the warm start part of the warm start/cold start code is executed.</p>
<h2>Non-Maskable Interrupts (NMI)</h2>
<p>NMI interrupts are generated by the following conditions:</p>
<ol>
<li><strong>Display list interrupt</strong> - Generated by the ANTIC chip</li>
<li><strong>TV vertical blank interrupt</strong> - Generated by the ANTIC chip</li>
<li><strong>[SYSTEM RESET] key</strong> - (400/800)</li>
</ol>
<p>When an NMI interrupt occurs, the hardware register NMIST [$D40F] is examined to determine what type of interrupt occurred. The computer is then directed through the proper RAM vector to service the interrupt.</p>
<h3>Display List Interrupts (DLIs)</h3>
<p>The computer makes no use of DLIs by default. The RAM vector points to an RTI instruction.</p>
<p>See <a node="[object Object]" href="/docs/forge/reference/advanced-topics/display-list-interrupts">Display List Interrupts</a> for complete DLI documentation.</p>
<h3>Vertical Blank Interrupts (VBIs)</h3>
<p>There are two stages to the VBI service routine. The second stage is only done if a critical function was not interrupted.</p>
<p><strong>Stage 1 (VBI):</strong></p>
<ul>
<li>The real time clock, RTCLOK [$0012 - $0014], is incremented</li>
<li>The attract mode variables are processed</li>
<li>System timer 1 is decremented. If it goes to zero the computer JSRs through system time-out vector 1</li>
</ul>
<p><strong>Stage 2 (VBI):</strong></p>
<ul>
<li>The hardware registers are loaded with the data in their shadow registers</li>
<li>System timer 2 is decremented. If it goes to zero the computer JSRs through the system time-out vector 2</li>
<li>System timers 3, 4, and 5 are decremented. If a timer goes to zero the computer sets system timer flags 3, 4, and/or 5</li>
<li>If auto-repeat is active, the auto-repeat process is done</li>
<li>The keyboard debounce timer is decremented if not 0</li>
<li>Information at the controller port registers is read, processed and placed in the proper shadow registers</li>
</ul>
<h3>[SYSTEM RESET] Interrupt</h3>
<p>If a [SYSTEM RESET] interrupt is generated on the 400/800 the computer jumps to the warm start routine.</p>
<h2>Interrupt Requests (IRQ)</h2>
<p>When an IRQ interrupt occurs the hardware register IRQST [$D20E], the PIA status registers, PACTL [$D302] and PBCTL [$D303] are examined to determine what caused the interrupt.</p>
<p>For each interrupt, the 6502 accumulator is pushed to the stack. The computer is then directed to the proper RAM vector to service the interrupt.</p>
<h2>Software Interrupt (BRK)</h2>
<p>The operating system doesn&#x27;t use software interrupts. The software interrupt vector points to a PLA followed by an RTI.</p>
<h2>Interrupt Vectors</h2>
<table><thead><tr><th>Label</th><th>Address</th><th>Type</th><th>Function</th></tr></thead><tbody><tr><td>VDSLST</td><td>$0200</td><td>NMI</td><td>DLI - Points to an RTI</td></tr><tr><td>VVBLKI</td><td>$0222</td><td>NMI</td><td>Stage 1 VBI</td></tr><tr><td>VVBLKD</td><td>$0224</td><td>NMI</td><td>Return-from-interrupt routine</td></tr><tr><td>CDTMA1</td><td>$0226</td><td>NMI</td><td>Time-out 1 (used by SIO)</td></tr><tr><td>CDTMA2</td><td>$0228</td><td>NMI</td><td>Time-out 2 (not used by OS)</td></tr><tr><td>VPRCED</td><td>$0202</td><td>IRQ</td><td>Not used (points to PLA,RTI)</td></tr><tr><td>VINTER</td><td>$0204</td><td>IRQ</td><td>Not used (PLA,RTI)</td></tr><tr><td>VKEYBD</td><td>$0208</td><td>IRQ</td><td>Keyboard interrupt</td></tr><tr><td>VSERIN</td><td>$020A</td><td>IRQ</td><td>Used by Serial I/O routine</td></tr><tr><td>VSEROR</td><td>$020C</td><td>IRQ</td><td>Used by SIO</td></tr><tr><td>VSEROC</td><td>$020E</td><td>IRQ</td><td>Used by SIO</td></tr><tr><td>VTIMR1</td><td>$0210</td><td>IRQ</td><td>Not used by OS (PLA,RTI)</td></tr><tr><td>VTIMR2</td><td>$0212</td><td>IRQ</td><td>Not used by OS (PLA,RTI)</td></tr><tr><td>VTIMR4</td><td>$0214</td><td>IRQ</td><td>?</td></tr><tr><td>VIMIRQ</td><td>$0216</td><td>IRQ</td><td>Main IRQ code</td></tr><tr><td>VBREAK</td><td>$0206</td><td>BRK</td><td>Unused by OS (PLA,RTI)</td></tr></tbody></table>
<h2>System Timers</h2>
<p>The following timers are updated during vertical blank (VBI) as noted above. If a timer is decremented to 0 the computer jumps through its associated vector or sets its associated flag.</p>
<table><thead><tr><th>Label</th><th>Address</th><th>Flag/Vector</th></tr></thead><tbody><tr><td>RTCLOK</td><td>$0012</td><td>3 byte clock ($0012 = MSB)</td></tr><tr><td>CDTMV1</td><td>$0218</td><td>CDTMA1 $0226 vector (SIO time-out)</td></tr><tr><td>CDTMV2</td><td>$021A</td><td>CDTMA2 $0228 vector</td></tr><tr><td>CDTMV3</td><td>$021C</td><td>CDTMF3 $022A flag</td></tr><tr><td>CDTMV4</td><td>$021E</td><td>CDTMF4 $022C flag</td></tr><tr><td>CDTMV5</td><td>$0220</td><td>CDTMF5 $022E flag</td></tr></tbody></table>
<h2>Hardware Interrupt Control</h2>
<p>There are two registers on the ANTIC chip which control interrupts. These registers can be used to disable interrupts if necessary. There are also two associated interrupt status registers.</p>
<p>The IRQ enable and status registers use the same address. The result is that reading the register does not reveal the enabled interrupts but the interrupts pending. IRQ interrupt enable data should usually be written to the OS shadow first. Reading the OS shadow tells which interrupts are enabled.</p>
<h3>Non-Maskable Interrupt Enable</h3>
<p><strong>NMIEN $D40E</strong></p>
<pre><code>7 6 5 4 3 2 1 0
----------------
| | | not used  |
----------------
</code></pre>
<ul>
<li><strong>Bit 7:</strong> 1 = DLI enabled</li>
<li><strong>Bit 6:</strong> 1 = VBI enabled</li>
</ul>
<h3>Non-Maskable Interrupt Status</h3>
<p><strong>NMIST $D40F</strong></p>
<pre><code>7 6 5 4 3 2 1 0
----------------
| | | | not used|
----------------
</code></pre>
<ul>
<li><strong>Bit 7:</strong> 1 = DLI pending</li>
<li><strong>Bit 6:</strong> 1 = VBI pending</li>
<li><strong>Bit 5:</strong> 1 = [SYSTEM RESET] key pending</li>
</ul>
<h3>Interrupt Request Enable</h3>
<p><strong>IRQEN $D20E</strong></p>
<pre><code>7 6 5 4 3 2 1 0
----------------
| | | | | | | | |
----------------
</code></pre>
<ul>
<li><strong>Bit 7:</strong> 1 = [BREAK] key interrupt enable</li>
<li><strong>Bit 6:</strong> 1 = keyboard interrupt enable</li>
<li><strong>Bit 5:</strong> 1 = serial input interrupt enable</li>
<li><strong>Bit 4:</strong> 1 = serial output interrupt enable</li>
<li><strong>Bit 3:</strong> 1 = serial output-finished interrupt enable</li>
<li><strong>Bit 2:</strong> 1 = timer 4 interrupt enable</li>
<li><strong>Bit 1:</strong> 1 = timer 2 interrupt enable</li>
<li><strong>Bit 0:</strong> 1 = timer 1 interrupt enable</li>
</ul>
<p>IRQEN has a shadow register, POKMSK [$0010 (16)].</p>
<h3>Interrupt Request Status</h3>
<p><strong>IRQST $D20E</strong> (read)</p>
<pre><code>7 6 5 4 3 2 1 0
----------------
| | | | | | | | |
----------------
</code></pre>
<ul>
<li><strong>Bit 7:</strong> 1 = [BREAK] key interrupt pending</li>
<li><strong>Bit 6:</strong> 1 = keyboard interrupt pending</li>
<li><strong>Bit 5:</strong> 1 = serial input interrupt pending</li>
<li><strong>Bit 4:</strong> 1 = serial output interrupt pending</li>
<li><strong>Bit 3:</strong> 1 = serial output-finished interrupt pending</li>
<li><strong>Bit 2:</strong> 1 = timer 4 interrupt pending</li>
<li><strong>Bit 1:</strong> 1 = timer 2 interrupt pending</li>
<li><strong>Bit 0:</strong> 1 = timer 1 interrupt pending</li>
</ul>
<h2>Wait for Horizontal Sync</h2>
<p>Writing any number to WSYNC [$D40A (54282)] will cause the computer to stop and wait for the next TV horizontal sync.</p>
<p>It is wise to use DLIs one TV line before needed then writing to WSYNC. This will keep other interrupts from causing DLIs to be serviced late. This can cause a DLI to change something in the middle of a scan line.</p>
<h2>Important Addresses</h2>
<table><thead><tr><th>Name</th><th>Address</th><th>Description</th></tr></thead><tbody><tr><td>POKMSK</td><td>$0010</td><td>IRQEN shadow</td></tr><tr><td>IRQEN</td><td>$D20E</td><td>Enables IRQs when written to</td></tr><tr><td>IRQST</td><td>$D20E</td><td>Gives IRQs waiting when read</td></tr><tr><td>PACTL</td><td>$D302</td><td>Peripheral A interrupt control</td></tr><tr><td>PBCTL</td><td>$D303</td><td>Peripheral B interrupt control</td></tr><tr><td>WSYNC</td><td>$D40A</td><td>Wait for horizontal sync</td></tr><tr><td>NMIEN</td><td>$D40E</td><td>NMI enable</td></tr><tr><td>NMIST</td><td>$D40F</td><td>NMI status</td></tr></tbody></table>
<h2>Related Topics</h2>
<ul>
<li><a node="[object Object]" href="/docs/forge/reference/advanced-topics/display-list-interrupts">Display List Interrupts</a> - DLI programming</li>
<li><a node="[object Object]" href="/docs/forge/hardware-registers">Hardware Registers</a> - Hardware register details</li>
<li><a node="[object Object]" href="/docs/forge/memory-map">Memory Map</a> - Memory map including interrupt vectors</li>
</ul></div></div></div></div></main><footer class="footer"><p>© 2026 Atari Foundry · Rick Collette · Software for Atari 8-bit builders.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"product":"forge","productDocs":{"product":"forge","files":[{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/cc65/README.md","relativePath":"cc65/README.md","relativeDir":"cc65","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/README.md","relativePath":"README.md","relativeDir":"","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/attributions.md","relativePath":"about/attributions.md","relativeDir":"about","filename":"attributions","slug":"attributions","name":"attributions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/cio-reference.md","relativePath":"advanced-topics/cio-reference.md","relativeDir":"advanced-topics","filename":"cio-reference","slug":"cio-reference","name":"cio-reference"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/compiling.md","relativePath":"getting-started/compiling.md","relativeDir":"getting-started","filename":"compiling","slug":"compiling","name":"compiling"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/differences.md","relativePath":"getting-started/differences.md","relativeDir":"getting-started","filename":"differences","slug":"differences","name":"differences"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/display-list-interrupts.md","relativePath":"advanced-topics/display-list-interrupts.md","relativeDir":"advanced-topics","filename":"display-list-interrupts","slug":"display-list-interrupts","name":"display-list-interrupts"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-guide.md","relativePath":"editor/editor-guide.md","relativeDir":"editor","filename":"editor-guide","slug":"editor-guide","name":"editor-guide"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-optimization.md","relativePath":"editor/editor-optimization.md","relativeDir":"editor","filename":"editor-optimization","slug":"editor-optimization","name":"editor-optimization"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/expressions.md","relativePath":"language-reference/expressions.md","relativeDir":"language-reference","filename":"expressions","slug":"expressions","name":"expressions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/first-steps.md","relativePath":"getting-started/first-steps.md","relativeDir":"getting-started","filename":"first-steps","slug":"first-steps","name":"first-steps"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/fujinet.md","relativePath":"advanced-topics/fujinet.md","relativeDir":"advanced-topics","filename":"fujinet","slug":"fujinet","name":"fujinet"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/functions.md","relativePath":"language-reference/functions.md","relativeDir":"language-reference","filename":"functions","slug":"functions","name":"functions"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/hardware-registers.md","relativePath":"reference/hardware-registers.md","relativeDir":"reference","filename":"hardware-registers","slug":"hardware-registers","name":"hardware-registers"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/index.md","relativePath":"index.md","relativeDir":"","filename":"index","slug":"index","name":"index"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/interrupts.md","relativePath":"reference/interrupts.md","relativeDir":"reference","filename":"interrupts","slug":"interrupts","name":"interrupts"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/introduction.md","relativePath":"getting-started/introduction.md","relativeDir":"getting-started","filename":"introduction","slug":"introduction","name":"introduction"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/iocb-structure.md","relativePath":"reference/iocb-structure.md","relativeDir":"reference","filename":"iocb-structure","slug":"iocb-structure","name":"iocb-structure"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/low-level-programming.md","relativePath":"advanced-topics/low-level-programming.md","relativeDir":"advanced-topics","filename":"low-level-programming","slug":"low-level-programming","name":"low-level-programming"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-map.md","relativePath":"reference/memory-map.md","relativeDir":"reference","filename":"memory-map","slug":"memory-map","name":"memory-map"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-usage.md","relativePath":"reference/memory-usage.md","relativeDir":"reference","filename":"memory-usage","slug":"memory-usage","name":"memory-usage"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/note-point.md","relativePath":"advanced-topics/note-point.md","relativeDir":"advanced-topics","filename":"note-point","slug":"note-point","name":"note-point"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/os-equates.md","relativePath":"reference/os-equates.md","relativeDir":"reference","filename":"os-equates","slug":"os-equates","name":"os-equates"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/r-handler.md","relativePath":"reference/r-handler.md","relativeDir":"reference","filename":"r-handler","slug":"r-handler","name":"r-handler"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/sio-operations.md","relativePath":"advanced-topics/sio-operations.md","relativeDir":"advanced-topics","filename":"sio-operations","slug":"sio-operations","name":"sio-operations"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/statements.md","relativePath":"language-reference/statements.md","relativeDir":"language-reference","filename":"statements","slug":"statements","name":"statements"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/syntax.md","relativePath":"language-reference/syntax.md","relativeDir":"language-reference","filename":"syntax","slug":"syntax","name":"syntax"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/why-forge.md","relativePath":"about/why-forge.md","relativeDir":"about","filename":"why-forge","slug":"why-forge","name":"why-forge"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/xio-reference.md","relativePath":"advanced-topics/xio-reference.md","relativeDir":"advanced-topics","filename":"xio-reference","slug":"xio-reference","name":"xio-reference"}],"navTree":{"cc65":{"_files":[{"name":"README","slug":"readme","path":"cc65/README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/cc65/README.md","isIndex":true}]},"_files":[{"name":"README","slug":"readme","path":"README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/README.md","isIndex":true},{"name":"index","slug":"index","path":"index.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/index.md","isIndex":false}],"about":{"_files":[{"name":"attributions","slug":"attributions","path":"about/attributions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/attributions.md","isIndex":false},{"name":"why-forge","slug":"why-forge","path":"about/why-forge.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/about/why-forge.md","isIndex":false}]},"advanced-topics":{"_files":[{"name":"cio-reference","slug":"cio-reference","path":"advanced-topics/cio-reference.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/cio-reference.md","isIndex":false},{"name":"display-list-interrupts","slug":"display-list-interrupts","path":"advanced-topics/display-list-interrupts.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/display-list-interrupts.md","isIndex":false},{"name":"fujinet","slug":"fujinet","path":"advanced-topics/fujinet.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/fujinet.md","isIndex":false},{"name":"low-level-programming","slug":"low-level-programming","path":"advanced-topics/low-level-programming.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/low-level-programming.md","isIndex":false},{"name":"note-point","slug":"note-point","path":"advanced-topics/note-point.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/note-point.md","isIndex":false},{"name":"sio-operations","slug":"sio-operations","path":"advanced-topics/sio-operations.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/sio-operations.md","isIndex":false},{"name":"xio-reference","slug":"xio-reference","path":"advanced-topics/xio-reference.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/advanced-topics/xio-reference.md","isIndex":false}]},"getting-started":{"_files":[{"name":"compiling","slug":"compiling","path":"getting-started/compiling.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/compiling.md","isIndex":false},{"name":"differences","slug":"differences","path":"getting-started/differences.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/differences.md","isIndex":false},{"name":"first-steps","slug":"first-steps","path":"getting-started/first-steps.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/first-steps.md","isIndex":false},{"name":"introduction","slug":"introduction","path":"getting-started/introduction.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/getting-started/introduction.md","isIndex":false}]},"editor":{"_files":[{"name":"editor-guide","slug":"editor-guide","path":"editor/editor-guide.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-guide.md","isIndex":false},{"name":"editor-optimization","slug":"editor-optimization","path":"editor/editor-optimization.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/editor/editor-optimization.md","isIndex":false}]},"language-reference":{"_files":[{"name":"expressions","slug":"expressions","path":"language-reference/expressions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/expressions.md","isIndex":false},{"name":"functions","slug":"functions","path":"language-reference/functions.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/functions.md","isIndex":false},{"name":"statements","slug":"statements","path":"language-reference/statements.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/statements.md","isIndex":false},{"name":"syntax","slug":"syntax","path":"language-reference/syntax.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/language-reference/syntax.md","isIndex":false}]},"reference":{"_files":[{"name":"hardware-registers","slug":"hardware-registers","path":"reference/hardware-registers.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/hardware-registers.md","isIndex":false},{"name":"interrupts","slug":"interrupts","path":"reference/interrupts.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/interrupts.md","isIndex":false},{"name":"iocb-structure","slug":"iocb-structure","path":"reference/iocb-structure.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/iocb-structure.md","isIndex":false},{"name":"memory-map","slug":"memory-map","path":"reference/memory-map.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-map.md","isIndex":false},{"name":"memory-usage","slug":"memory-usage","path":"reference/memory-usage.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/memory-usage.md","isIndex":false},{"name":"os-equates","slug":"os-equates","path":"reference/os-equates.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/os-equates.md","isIndex":false},{"name":"r-handler","slug":"r-handler","path":"reference/r-handler.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/r-handler.md","isIndex":false}]}}},"docFile":{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/forge/reference/interrupts.md","relativePath":"reference/interrupts.md","relativeDir":"reference","filename":"interrupts","slug":"interrupts","name":"interrupts","content":"# System Interrupts\n\nSystem interrupt documentation for the Atari 8-bit computers.\n\n## Overview\n\nThere are four types of interrupts which can occur with the 6502 microprocessor:\n\n1. **Chip reset**\n2. **IRQ** (interrupt request, maskable)\n3. **NMI** (non-maskable interrupt)\n4. **Software interrupt** (BRK instruction)\n\n## Chip Reset\n\nOn the 400/800 the chip reset occurs only upon power-up and causes the computer to do a cold start. On later models, pressing [SYSTEM RESET] will cause a chip reset but the computer then does a warm start. On the 400/800, the [SYSTEM RESET] key generates a NMI interrupt.\n\n## Cold Start\n\nThis is a synopsis of the cold start routine:\n\n1. The warm start flag [$0008] is set to 0 (false)\n2. If a cartridge slot contains a diagnostic cartridge, control is handed to the cartridge\n3. The end of RAM is determined by trying to complement the first byte of each 4K block of memory\n4. Hardware registers at $D000 - $D4FF (except $D100 - $D1FF) are cleared\n5. RAM is cleared from $0008 to the top of RAM\n6. The user program jump vector, DOSVEC [$000A] is set to point to the black board mode (Atari logo display mode in XL/XE models)\n7. The screen margins are set to 2 and 39\n8. Interrupt vectors are initialized\n9. Bottom of free RAM pointer, MEMLO [$02E7], is set to point to $0700\n10. Resident CIO handlers are initialized\n11. If the [START] key is pressed the cassette boot request flag, CKEY [$004A], is set\n12. The CIO device table is initialized\n13. If a cartridge is present it is initialized\n14. Channel 0 is opened to the screen editor. The top-of-free-RAM pointer, MEMTOP [$02E5], is set to point below the screen region\n15. If the cassette boot flag is set the cassette is booted\n16. If there is no cartridge present or a cartridge doesn't prevent it, the disk is booted\n17. The cold start flag is reset\n18. If there is a cartridge present, the computer jumps to the cartridge's run vector\n19. If there is no cartridge present the computer jumps through the vector DOSVEC [$000A (10)]\n\n## Warm Start\n\n1. The warm start flag is set to $7F (true)\n2. Cold start steps 2 - 4 are executed\n3. RAM is cleared from $0010 - $007F and $0200 - $03FF\n4. Cold start steps 7 - 14 are executed\n5. If cassette booted software is present the computer JSRs through CASINI [$0002]\n6. If disk booted software is present the computer JSRs through DOSINI [$000C (12)]\n\nThe difference between cold start and warm start is the condition of the warm start flag, WARMST, [$0008]. If this flag is 0 a complete cold start is executed. If the flag is anything other than 0 then only the warm start part of the warm start/cold start code is executed.\n\n## Non-Maskable Interrupts (NMI)\n\nNMI interrupts are generated by the following conditions:\n\n1. **Display list interrupt** - Generated by the ANTIC chip\n2. **TV vertical blank interrupt** - Generated by the ANTIC chip\n3. **[SYSTEM RESET] key** - (400/800)\n\nWhen an NMI interrupt occurs, the hardware register NMIST [$D40F] is examined to determine what type of interrupt occurred. The computer is then directed through the proper RAM vector to service the interrupt.\n\n### Display List Interrupts (DLIs)\n\nThe computer makes no use of DLIs by default. The RAM vector points to an RTI instruction.\n\nSee [Display List Interrupts](../advanced-topics/display-list-interrupts.md) for complete DLI documentation.\n\n### Vertical Blank Interrupts (VBIs)\n\nThere are two stages to the VBI service routine. The second stage is only done if a critical function was not interrupted.\n\n**Stage 1 (VBI):**\n- The real time clock, RTCLOK [$0012 - $0014], is incremented\n- The attract mode variables are processed\n- System timer 1 is decremented. If it goes to zero the computer JSRs through system time-out vector 1\n\n**Stage 2 (VBI):**\n- The hardware registers are loaded with the data in their shadow registers\n- System timer 2 is decremented. If it goes to zero the computer JSRs through the system time-out vector 2\n- System timers 3, 4, and 5 are decremented. If a timer goes to zero the computer sets system timer flags 3, 4, and/or 5\n- If auto-repeat is active, the auto-repeat process is done\n- The keyboard debounce timer is decremented if not 0\n- Information at the controller port registers is read, processed and placed in the proper shadow registers\n\n### [SYSTEM RESET] Interrupt\n\nIf a [SYSTEM RESET] interrupt is generated on the 400/800 the computer jumps to the warm start routine.\n\n## Interrupt Requests (IRQ)\n\nWhen an IRQ interrupt occurs the hardware register IRQST [$D20E], the PIA status registers, PACTL [$D302] and PBCTL [$D303] are examined to determine what caused the interrupt.\n\nFor each interrupt, the 6502 accumulator is pushed to the stack. The computer is then directed to the proper RAM vector to service the interrupt.\n\n## Software Interrupt (BRK)\n\nThe operating system doesn't use software interrupts. The software interrupt vector points to a PLA followed by an RTI.\n\n## Interrupt Vectors\n\n| Label | Address | Type | Function |\n|-------|---------|------|----------|\n| VDSLST | $0200 | NMI | DLI - Points to an RTI |\n| VVBLKI | $0222 | NMI | Stage 1 VBI |\n| VVBLKD | $0224 | NMI | Return-from-interrupt routine |\n| CDTMA1 | $0226 | NMI | Time-out 1 (used by SIO) |\n| CDTMA2 | $0228 | NMI | Time-out 2 (not used by OS) |\n| VPRCED | $0202 | IRQ | Not used (points to PLA,RTI) |\n| VINTER | $0204 | IRQ | Not used (PLA,RTI) |\n| VKEYBD | $0208 | IRQ | Keyboard interrupt |\n| VSERIN | $020A | IRQ | Used by Serial I/O routine |\n| VSEROR | $020C | IRQ | Used by SIO |\n| VSEROC | $020E | IRQ | Used by SIO |\n| VTIMR1 | $0210 | IRQ | Not used by OS (PLA,RTI) |\n| VTIMR2 | $0212 | IRQ | Not used by OS (PLA,RTI) |\n| VTIMR4 | $0214 | IRQ | ? |\n| VIMIRQ | $0216 | IRQ | Main IRQ code |\n| VBREAK | $0206 | BRK | Unused by OS (PLA,RTI) |\n\n## System Timers\n\nThe following timers are updated during vertical blank (VBI) as noted above. If a timer is decremented to 0 the computer jumps through its associated vector or sets its associated flag.\n\n| Label | Address | Flag/Vector |\n|-------|---------|-------------|\n| RTCLOK | $0012 | 3 byte clock ($0012 = MSB) |\n| CDTMV1 | $0218 | CDTMA1 $0226 vector (SIO time-out) |\n| CDTMV2 | $021A | CDTMA2 $0228 vector |\n| CDTMV3 | $021C | CDTMF3 $022A flag |\n| CDTMV4 | $021E | CDTMF4 $022C flag |\n| CDTMV5 | $0220 | CDTMF5 $022E flag |\n\n## Hardware Interrupt Control\n\nThere are two registers on the ANTIC chip which control interrupts. These registers can be used to disable interrupts if necessary. There are also two associated interrupt status registers.\n\nThe IRQ enable and status registers use the same address. The result is that reading the register does not reveal the enabled interrupts but the interrupts pending. IRQ interrupt enable data should usually be written to the OS shadow first. Reading the OS shadow tells which interrupts are enabled.\n\n### Non-Maskable Interrupt Enable\n\n**NMIEN $D40E**\n\n```\n7 6 5 4 3 2 1 0\n----------------\n| | | not used  |\n----------------\n```\n\n- **Bit 7:** 1 = DLI enabled\n- **Bit 6:** 1 = VBI enabled\n\n### Non-Maskable Interrupt Status\n\n**NMIST $D40F**\n\n```\n7 6 5 4 3 2 1 0\n----------------\n| | | | not used|\n----------------\n```\n\n- **Bit 7:** 1 = DLI pending\n- **Bit 6:** 1 = VBI pending\n- **Bit 5:** 1 = [SYSTEM RESET] key pending\n\n### Interrupt Request Enable\n\n**IRQEN $D20E**\n\n```\n7 6 5 4 3 2 1 0\n----------------\n| | | | | | | | |\n----------------\n```\n\n- **Bit 7:** 1 = [BREAK] key interrupt enable\n- **Bit 6:** 1 = keyboard interrupt enable\n- **Bit 5:** 1 = serial input interrupt enable\n- **Bit 4:** 1 = serial output interrupt enable\n- **Bit 3:** 1 = serial output-finished interrupt enable\n- **Bit 2:** 1 = timer 4 interrupt enable\n- **Bit 1:** 1 = timer 2 interrupt enable\n- **Bit 0:** 1 = timer 1 interrupt enable\n\nIRQEN has a shadow register, POKMSK [$0010 (16)].\n\n### Interrupt Request Status\n\n**IRQST $D20E** (read)\n\n```\n7 6 5 4 3 2 1 0\n----------------\n| | | | | | | | |\n----------------\n```\n\n- **Bit 7:** 1 = [BREAK] key interrupt pending\n- **Bit 6:** 1 = keyboard interrupt pending\n- **Bit 5:** 1 = serial input interrupt pending\n- **Bit 4:** 1 = serial output interrupt pending\n- **Bit 3:** 1 = serial output-finished interrupt pending\n- **Bit 2:** 1 = timer 4 interrupt pending\n- **Bit 1:** 1 = timer 2 interrupt pending\n- **Bit 0:** 1 = timer 1 interrupt pending\n\n## Wait for Horizontal Sync\n\nWriting any number to WSYNC [$D40A (54282)] will cause the computer to stop and wait for the next TV horizontal sync.\n\nIt is wise to use DLIs one TV line before needed then writing to WSYNC. This will keep other interrupts from causing DLIs to be serviced late. This can cause a DLI to change something in the middle of a scan line.\n\n## Important Addresses\n\n| Name | Address | Description |\n|------|---------|-------------|\n| POKMSK | $0010 | IRQEN shadow |\n| IRQEN | $D20E | Enables IRQs when written to |\n| IRQST | $D20E | Gives IRQs waiting when read |\n| PACTL | $D302 | Peripheral A interrupt control |\n| PBCTL | $D303 | Peripheral B interrupt control |\n| WSYNC | $D40A | Wait for horizontal sync |\n| NMIEN | $D40E | NMI enable |\n| NMIST | $D40F | NMI status |\n\n## Related Topics\n\n- [Display List Interrupts](../advanced-topics/display-list-interrupts.md) - DLI programming\n- [Hardware Registers](hardware-registers.md) - Hardware register details\n- [Memory Map](memory-map.md) - Memory map including interrupt vectors\n"},"currentPath":"reference/interrupts"},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["forge","reference","interrupts"]},"buildId":"uKcVMkypfjITnNYGcdC5l","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>