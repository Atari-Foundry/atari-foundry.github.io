<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">API REFERENCE | crucible Documentation | Atari Foundry</title><meta name="description" content="crucible documentation: API REFERENCE" data-next-head=""/><link rel="preload" href="/images/foundry_logo_50H.png" as="image" data-next-head=""/><link rel="preload" href="/_next/static/chunks/c81f129e50a5fd79.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/c81f129e50a5fd79.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/e8a4a4ae55bc5744.js" defer=""></script><script src="/_next/static/chunks/00dac80f236dcabb.js" defer=""></script><script src="/_next/static/chunks/44f6bc00d9aaf830.js" defer=""></script><script src="/_next/static/chunks/fd7cb30d70431a0f.js" defer=""></script><script src="/_next/static/chunks/turbopack-4769270d21ef6607.js" defer=""></script><script src="/_next/static/chunks/1b081b821847ed60.js" defer=""></script><script src="/_next/static/chunks/76d09b6b03e70f66.js" defer=""></script><script src="/_next/static/chunks/b56fd671c61106a7.js" defer=""></script><script src="/_next/static/chunks/turbopack-d90ce600b0329ce0.js" defer=""></script><script src="/_next/static/CnF04P5ob_bUVxETgw2P_/_ssgManifest.js" defer=""></script><script src="/_next/static/CnF04P5ob_bUVxETgw2P_/_buildManifest.js" defer=""></script></head><body><div id="__next"><div class="crt"><div class="scanlines" aria-hidden="true"></div><div class="noise" aria-hidden="true"></div><nav class="nav"><a class="nav-brand" href="/"><img alt="Atari Foundry icon" width="72" height="50" decoding="async" data-nimg="1" style="color:transparent;height:40px;width:auto" src="/images/foundry_logo_50H.png"/><div><span class="nav-brand-title">Atari Foundry</span><span class="nav-brand-sub">Products for Atari 8-bit</span></div></a><ul class="nav-links"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about">About</a></li><li class="nav-item"><a class="nav-link" href="/vault">Vault</a></li><li class="nav-item has-children"><button type="button" class="nav-link nav-trigger active" aria-haspopup="true" aria-expanded="false">Docs</button><div class="nav-dropdown"><a class="nav-dropdown-link" href="/docs/crucible">Crucible</a><a class="nav-dropdown-link" href="/docs/atrforge">atrforge</a><a class="nav-dropdown-link" href="/docs/forge">FORGE</a></div></li><li class="nav-item"><a class="nav-link" href="/downloads">Downloads</a></li><li class="nav-item"><a class="nav-link" href="/support">Support</a></li></ul></nav><header class="subhero"><p class="label">crucible<!-- --> Documentation</p><h1 class="page-title">API REFERENCE</h1></header><main><div class="docs-layout"><aside class="docs-sidebar"><nav class="docs-nav"><div class="docs-nav-section"><h3>Documentation</h3><ul style="list-style:none;padding:0;margin:0"><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/readme">README</a></li><li><a class="doc-link active" style="padding-left:0rem" href="/docs/crucible/api-reference">API REFERENCE</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/architecture">ARCHITECTURE</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/attributions">ATTRIBUTIONS</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/building">BUILDING</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/changelog">CHANGELOG</a></li><li><a class="doc-link " style="padding-left:0rem" href="/docs/crucible/user-guide">USER GUIDE</a></li></ul></div></nav></aside><div class="docs-content"><div class="docs-body"><div class="doc-markdown"><h1>Crucible API Reference</h1>
<h2>Table of Contents</h2>
<ol>
<li><a node="[object Object]" href="/docs/crucible/api-reference#overview">Overview</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#core-simulator-api-sim65">Core Simulator API (sim65)</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#atari-bios-api">Atari BIOS API</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#atr-filesystem-api">ATR Filesystem API</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#host-filesystem-api">Host Filesystem API</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#sio-api">SIO API</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#callback-system">Callback System</a></li>
<li><a node="[object Object]" href="/docs/crucible/api-reference#data-structures">Data Structures</a></li>
</ol>
<h2>Overview</h2>
<p>This document provides a complete reference for the crucible API. The API is organized into several modules:</p>
<ul>
<li><strong>sim65</strong>: Core 6502 CPU simulator</li>
<li><strong>atari</strong>: Atari BIOS emulation</li>
<li><strong>atrfs</strong>: ATR filesystem access</li>
<li><strong>athost</strong>: Host filesystem device</li>
<li><strong>atsio</strong>: SIO and ATR image access</li>
</ul>
<h2>Core Simulator API (sim65)</h2>
<h3>Simulator Creation and Management</h3>
<h4><code>sim65 sim65_new(void)</code></h4>
<p>Creates a new simulator instance.</p>
<p><strong>Returns</strong>: Simulator handle, or NULL on error</p>
<p><strong>Example</strong>:</p>
<pre><pre class="language-c"><code class="language-c">sim65 s = sim65_new();
if (!s) {
    fprintf(stderr, &quot;Failed to create simulator\n&quot;);
    exit(1);
}
</code></pre></pre>
<h4><code>void sim65_free(sim65 s)</code></h4>
<p>Frees a simulator instance and all associated memory.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<h3>Memory Management</h3>
<h4><code>void sim65_add_ram(sim65 s, unsigned addr, unsigned len)</code></h4>
<p>Adds an uninitialized RAM region.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Starting address</li>
<li><code>len</code>: Length in bytes</li>
</ul>
<h4><code>void sim65_add_zeroed_ram(sim65 s, unsigned addr, unsigned len)</code></h4>
<p>Adds a zeroed RAM region.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Starting address</li>
<li><code>len</code>: Length in bytes</li>
</ul>
<h4><code>void sim65_add_data_ram(sim65 s, unsigned addr, const unsigned char *data, unsigned len)</code></h4>
<p>Adds a RAM region initialized with data.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Starting address</li>
<li><code>data</code>: Initial data</li>
<li><code>len</code>: Length in bytes</li>
</ul>
<h4><code>void sim65_add_data_rom(sim65 s, unsigned addr, const unsigned char *data, unsigned len)</code></h4>
<p>Adds a ROM region (read-only).</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Starting address</li>
<li><code>data</code>: ROM data</li>
<li><code>len</code>: Length in bytes</li>
</ul>
<h4><code>unsigned sim65_get_byte(sim65 s, unsigned addr)</code></h4>
<p>Reads a byte from memory.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Memory address</li>
</ul>
<p><strong>Returns</strong>: Byte value, or 0x100 if invalid/uninitialized</p>
<h3>Execution Control</h3>
<h4><code>enum sim65_error sim65_run(sim65 s, struct sim65_reg *regs, unsigned addr)</code></h4>
<p>Runs the simulation from the given address.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>regs</code>: Initial register values (NULL for zero)</li>
<li><code>addr</code>: Starting address</li>
</ul>
<p><strong>Returns</strong>: Error code (0 = success)</p>
<p><strong>Example</strong>:</p>
<pre><pre class="language-c"><code class="language-c">struct sim65_reg regs = {0};
regs.pc = 0x0600;
enum sim65_error err = sim65_run(s, &amp;regs, 0x0600);
</code></pre></pre>
<h4><code>enum sim65_error sim65_call(sim65 s, struct sim65_reg *regs, unsigned addr)</code></h4>
<p>Calls a subroutine via JSR and returns on RTS.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>regs</code>: Register values (NULL for zero)</li>
<li><code>addr</code>: Subroutine address</li>
</ul>
<p><strong>Returns</strong>: Error code (0 = success, <code>sim65_err_call_ret</code> = normal return)</p>
<h3>Callbacks</h3>
<h4><code>void sim65_add_callback(sim65 s, unsigned addr, sim65_callback cb, enum sim65_cb_type type)</code></h4>
<p>Adds a callback at a specific address.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Address for callback</li>
<li><code>cb</code>: Callback function</li>
<li><code>type</code>: Callback type (read, write, or exec)</li>
</ul>
<p><strong>Callback Types</strong>:</p>
<ul>
<li><code>sim65_cb_read</code>: Memory read callback</li>
<li><code>sim65_cb_write</code>: Memory write callback</li>
<li><code>sim65_cb_exec</code>: Instruction execution callback</li>
</ul>
<h4><code>void sim65_add_callback_range(sim65 s, unsigned addr, unsigned len, sim65_callback cb, enum sim65_cb_type type)</code></h4>
<p>Adds callbacks for an address range.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Starting address</li>
<li><code>len</code>: Range length</li>
<li><code>cb</code>: Callback function</li>
<li><code>type</code>: Callback type</li>
</ul>
<h3>Debugging and Tracing</h3>
<h4><code>void sim65_set_debug(sim65 s, enum sim65_debug level)</code></h4>
<p>Sets debug output level.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>level</code>: Debug level (<code>sim65_debug_none</code>, <code>sim65_debug_messages</code>, <code>sim65_debug_trace</code>)</li>
</ul>
<h4><code>void sim65_set_trace_file(sim65 s, FILE *f)</code></h4>
<p>Sets trace output file.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>f</code>: File handle (NULL for stderr)</li>
</ul>
<h4><code>void sim65_set_error_level(sim65 s, enum sim65_error_lvl level)</code></h4>
<p>Sets error reporting level.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>level</code>: Error level (<code>sim65_errlvl_none</code>, <code>sim65_errlvl_memory</code>, <code>sim65_errlvl_full</code>)</li>
</ul>
<h4><code>int sim65_dprintf(sim65 s, const char *format, ...)</code></h4>
<p>Prints debug message (if debug enabled).</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>format</code>: printf-style format string</li>
<li><code>...</code>: Format arguments</li>
</ul>
<h4><code>int sim65_eprintf(sim65 s, const char *format, ...)</code></h4>
<p>Prints error message (always).</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>format</code>: printf-style format string</li>
<li><code>...</code>: Format arguments</li>
</ul>
<h3>Profiling</h3>
<h4><code>void sim65_set_profiling(sim65 s, int enable)</code></h4>
<p>Enables or disables profiling.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>enable</code>: Non-zero to enable</li>
</ul>
<h4><code>struct sim65_profile sim65_get_profile_info(sim65 s)</code></h4>
<p>Gets profiling information.</p>
<p><strong>Returns</strong>: Profile structure with cycle counts and statistics</p>
<h3>Utility Functions</h3>
<h4><code>void sim65_set_flags(sim65 s, uint8_t flag, uint8_t val)</code></h4>
<p>Sets or clears processor flags.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>flag</code>: Flag mask (SIM65_FLAG_C, SIM65_FLAG_Z, etc.)</li>
<li><code>val</code>: Value (0 = clear, non-zero = set)</li>
</ul>
<h4><code>void sim65_set_cycle_limit(sim65 s, uint64_t limit)</code></h4>
<p>Sets cycle execution limit.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>limit</code>: Maximum cycles (0 = unlimited)</li>
</ul>
<h4><code>void sim65_print_reg(const sim65 s, FILE *f)</code></h4>
<p>Prints current register values.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>f</code>: Output file</li>
</ul>
<h4><code>const char *sim65_error_str(sim65 s, enum sim65_error e)</code></h4>
<p>Gets error message string.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>e</code>: Error code</li>
</ul>
<p><strong>Returns</strong>: Error message string</p>
<h2>Atari BIOS API</h2>
<h3>Initialization</h3>
<h4><code>void atari_init(sim65 s, emu_options *opts)</code></h4>
<p>Initializes Atari BIOS emulation.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>opts</code>: Emulation options (NULL for defaults)</li>
</ul>
<p><strong>Options Structure</strong>:</p>
<pre><pre class="language-c"><code class="language-c">typedef struct {
    int (*get_char)(void);  // Character input callback
    void (*put_char)(int);  // Character output callback
    int flags;              // Option flags
} emu_options;
</code></pre></pre>
<p><strong>Option Flags</strong>:</p>
<ul>
<li><code>atari_opt_no_dos</code>: Skip DOS emulation</li>
<li><code>atari_opt_pal</code>: PAL timing (50Hz)</li>
<li><code>atari_opt_cycletime</code>: Cycle-based timing</li>
<li><code>atari_opt_atari_mathpack</code>: Use original Atari math pack</li>
</ul>
<h4><code>int atari_add_option(emu_options *opt, const char *str)</code></h4>
<p>Parses option string and updates options.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>opt</code>: Options structure</li>
<li><code>str</code>: Option string (e.g., &quot;pal,fastmath&quot;)</li>
</ul>
<p><strong>Returns</strong>: 0 on success, non-zero on error</p>
<h3>File Loading</h3>
<h4><code>enum sim65_error atari_xex_load(sim65 s, const char *name, int check)</code></h4>
<p>Loads and runs a XEX file.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>name</code>: XEX filename</li>
<li><code>check</code>: Non-zero to validate format</li>
</ul>
<p><strong>Returns</strong>: Error code</p>
<h4><code>enum sim65_error atari_rom_load(sim65 s, int addr, const char *name)</code></h4>
<p>Loads a ROM file at the given address.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Load address</li>
<li><code>name</code>: ROM filename</li>
</ul>
<p><strong>Returns</strong>: Error code</p>
<h4><code>int atari_load_image(sim65 s, const char *file_name)</code></h4>
<p>Loads an ATR disk image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>file_name</code>: ATR filename</li>
</ul>
<p><strong>Returns</strong>: 0 on success, non-zero on error</p>
<h4><code>enum sim65_error atari_boot_image(sim65 s)</code></h4>
<p>Boots from a loaded disk image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<p><strong>Returns</strong>: Error code</p>
<h3>DOS Configuration</h3>
<h4><code>void atari_dos_set_root(sim65 s, const char *path)</code></h4>
<p>Sets root path for D: device.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>path</code>: Root directory path (NULL for current directory)</li>
</ul>
<h4><code>void atari_dos_add_cmdline(sim65 s, const char *cmd)</code></h4>
<p>Adds command-line argument to DOS.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>cmd</code>: Command-line string</li>
</ul>
<h3>Utility Functions</h3>
<h4><code>void add_rts_callback(sim65 s, unsigned addr, unsigned len, sim65_callback cb)</code></h4>
<p>Installs callback with RTS instruction.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>addr</code>: Callback address</li>
<li><code>len</code>: Range length</li>
<li><code>cb</code>: Callback function</li>
</ul>
<h4><code>int atari_get_flags(sim65 s)</code></h4>
<p>Gets current emulation flags.</p>
<p><strong>Returns</strong>: Flags value</p>
<h2>ATR Filesystem API</h2>
<h3>File Operations</h3>
<h4><code>int atrfs_find_file(sim65 s, const char *path, struct atr_dir_entry *entry)</code></h4>
<p>Finds a file in the ATR filesystem.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>path</code>: File path (e.g., &quot;FILE.EXT&quot; or &quot;DIR\FILE.EXT&quot;)</li>
<li><code>entry</code>: Output directory entry</li>
</ul>
<p><strong>Returns</strong>: 0 on success, -1 on error</p>
<p><strong>Example</strong>:</p>
<pre><pre class="language-c"><code class="language-c">struct atr_dir_entry entry;
if (atrfs_find_file(s, &quot;MYFILE.TXT&quot;, &amp;entry) == 0) {
    printf(&quot;Found file: %s\n&quot;, entry.filename);
}
</code></pre></pre>
<h4><code>struct atr_file_handle *atrfs_open_file(sim65 s, uint16_t start_sector, uint32_t size)</code></h4>
<p>Opens a file handle for reading.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>start_sector</code>: Starting sector number</li>
<li><code>size</code>: File size in bytes</li>
</ul>
<p><strong>Returns</strong>: File handle, or NULL on error</p>
<h4><code>int atrfs_read_byte(struct atr_file_handle *fh)</code></h4>
<p>Reads a byte from file.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>fh</code>: File handle</li>
</ul>
<p><strong>Returns</strong>: Byte value, or -1 on EOF/error</p>
<h4><code>int atrfs_seek(struct atr_file_handle *fh, uint32_t position)</code></h4>
<p>Seeks to position in file.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>fh</code>: File handle</li>
<li><code>position</code>: Byte position</li>
</ul>
<p><strong>Returns</strong>: 0 on success, -1 on error</p>
<h4><code>void atrfs_close_file(struct atr_file_handle *fh)</code></h4>
<p>Closes and frees file handle.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>fh</code>: File handle</li>
</ul>
<h3>Directory Operations</h3>
<h4><code>int atrfs_read_directory(sim65 s, uint16_t dir_sector, struct atr_dir_entry *entries, int max_entries)</code></h4>
<p>Reads directory entries.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>dir_sector</code>: Directory sector number</li>
<li><code>entries</code>: Output array</li>
<li><code>max_entries</code>: Maximum entries to read</li>
</ul>
<p><strong>Returns</strong>: Number of entries read, or -1 on error</p>
<h2>Host Filesystem API</h2>
<h3>Initialization</h3>
<h4><code>void atari_host_init(sim65 s)</code></h4>
<p>Initializes H: device handler.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<h4><code>void atari_host_set_root(sim65 s, const char *path)</code></h4>
<p>Sets root path for H: device.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>path</code>: Root directory path (NULL for current directory)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><pre class="language-c"><code class="language-c">atari_host_init(s);
atari_host_set_root(s, &quot;/home/user/atari_files&quot;);
</code></pre></pre>
<h2>SIO API</h2>
<h3>Initialization</h3>
<h4><code>void atari_sio_init(sim65 s)</code></h4>
<p>Initializes SIO emulation.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<h3>Disk Image Operations</h3>
<h4><code>int atari_sio_load_image(sim65 s, const char *file_name)</code></h4>
<p>Loads an ATR disk image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>file_name</code>: ATR filename</li>
</ul>
<p><strong>Returns</strong>: 0 on success, non-zero on error</p>
<h4><code>enum sim65_error atari_sio_boot(sim65 s)</code></h4>
<p>Boots from loaded disk image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<p><strong>Returns</strong>: Error code</p>
<h3>ATR Access</h3>
<h4><code>const struct atr_disk_image *atari_sio_get_disk_image(sim65 s)</code></h4>
<p>Gets pointer to loaded disk image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
</ul>
<p><strong>Returns</strong>: Disk image structure, or NULL if not loaded</p>
<h4><code>int atari_sio_read_sector(sim65 s, unsigned sector, uint8_t *buffer, unsigned *size)</code></h4>
<p>Reads a sector from ATR image.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>sector</code>: Sector number (1-based)</li>
<li><code>buffer</code>: Output buffer</li>
<li><code>size</code>: Input/output buffer size</li>
</ul>
<p><strong>Returns</strong>: 0 on success, non-zero on error</p>
<h2>Callback System</h2>
<h3>Callback Function Signature</h3>
<pre><pre class="language-c"><code class="language-c">typedef int (*sim65_callback)(sim65 s, struct sim65_reg *regs, 
                               unsigned addr, int data);
</code></pre></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>s</code>: Simulator handle</li>
<li><code>regs</code>: Register values before instruction</li>
<li><code>addr</code>: Address causing callback</li>
<li><code>data</code>:<!-- -->
<ul>
<li>For read callbacks: unused</li>
<li>For write callbacks: value being written</li>
<li>For exec callbacks: <code>sim65_cb_exec</code></li>
</ul>
</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li>For read callbacks: byte value (0-255)</li>
<li>For other callbacks: error code (0 = success, negative = error)</li>
</ul>
<h3>Example Callback</h3>
<pre><pre class="language-c"><code class="language-c">static int my_callback(sim65 s, struct sim65_reg *regs, 
                       unsigned addr, int data)
{
    if (data == sim65_cb_exec) {
        // Instruction execution callback
        sim65_dprintf(s, &quot;Executing at $%04X\n&quot;, addr);
        // Simulate RTS if needed
        return 0;
    }
    return 0;
}

// Register callback
sim65_add_callback(s, 0xE456, my_callback, sim65_cb_exec);
</code></pre></pre>
<h2>Data Structures</h2>
<h3><code>struct sim65_reg</code></h3>
<p>CPU register values.</p>
<pre><pre class="language-c"><code class="language-c">struct sim65_reg {
    uint16_t pc;  // Program counter
    uint8_t a;    // Accumulator
    uint8_t x;    // X register
    uint8_t y;    // Y register
    uint8_t p;    // Processor status
    uint8_t s;    // Stack pointer
};
</code></pre></pre>
<h3><code>struct atr_file_handle</code></h3>
<p>ATR file handle.</p>
<pre><pre class="language-c"><code class="language-c">struct atr_file_handle {
    uint16_t start_sector;
    uint16_t current_sector;
    uint32_t file_size;
    uint32_t position;
    uint8_t sector_buffer[256];
    int sector_pos;
    int sector_size;
    sim65 sim;
};
</code></pre></pre>
<h3><code>struct atr_dir_entry</code></h3>
<p>ATR directory entry.</p>
<pre><pre class="language-c"><code class="language-c">struct atr_dir_entry {
    uint8_t flags;
    uint16_t start_sector;
    uint16_t sector_count;
    uint32_t byte_count;
    char filename[12];
    uint8_t attributes;
    int is_hidden;
    int is_protected;
    int is_archived;
};
</code></pre></pre>
<h3><code>struct atr_disk_image</code></h3>
<p>ATR disk image structure.</p>
<pre><pre class="language-c"><code class="language-c">struct atr_disk_image {
    uint8_t *data;
    unsigned sec_size;
    unsigned sec_count;
};
</code></pre></pre>
<h3><code>enum sim65_error</code></h3>
<p>Error codes.</p>
<pre><pre class="language-c"><code class="language-c">enum sim65_error {
    sim65_err_none = 0,
    sim65_err_exec_undef = -1,
    sim65_err_exec_uninit = -2,
    sim65_err_read_undef = -3,
    sim65_err_read_uninit = -4,
    sim65_err_write_undef = -5,
    sim65_err_write_rom = -6,
    sim65_err_break = -7,
    sim65_err_invalid_ins = -8,
    sim65_err_call_ret = -9,
    sim65_err_cycle_limit = -10,
    sim65_err_user = -11
};
</code></pre></pre>
<h2>Error Handling</h2>
<p>All functions that can fail return error codes. Check return values:</p>
<pre><pre class="language-c"><code class="language-c">enum sim65_error err = atari_xex_load(s, &quot;program.xex&quot;, 1);
if (err != sim65_err_none) {
    fprintf(stderr, &quot;Error: %s\n&quot;, sim65_error_str(s, err));
}
</code></pre></pre>
<h2>Memory Management</h2>
<ul>
<li>Simulator handles memory allocation internally</li>
<li>File handles must be closed with <code>atrfs_close_file()</code></li>
<li>Simulator instance must be freed with <code>sim65_free()</code></li>
</ul>
<h2>Thread Safety</h2>
<p>The API is <strong>not</strong> thread-safe. Use one simulator instance per thread.</p>
<h2>See Also</h2>
<ul>
<li><a node="[object Object]" href="/docs/crucible/user-guide">User Guide</a> - Usage examples</li>
<li><a node="[object Object]" href="/docs/crucible/architecture">Architecture</a> - System design</li>
<li><a node="[object Object]" href="/docs/crucible/building">Building Guide</a> - Build instructions</li>
</ul></div></div></div></div></main><footer class="footer"><p>© 2026 Atari Foundry · Rick Collette · Software for Atari 8-bit builders.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"product":"crucible","productDocs":{"product":"crucible","files":[{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/README.md","relativePath":"README.md","relativeDir":"","filename":"README","slug":"readme","name":"README"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","relativePath":"API_REFERENCE.md","relativeDir":"","filename":"API_REFERENCE","slug":"api-reference","name":"API REFERENCE"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ARCHITECTURE.md","relativePath":"ARCHITECTURE.md","relativeDir":"","filename":"ARCHITECTURE","slug":"architecture","name":"ARCHITECTURE"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ATTRIBUTIONS.md","relativePath":"ATTRIBUTIONS.md","relativeDir":"","filename":"ATTRIBUTIONS","slug":"attributions","name":"ATTRIBUTIONS"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/BUILDING.md","relativePath":"BUILDING.md","relativeDir":"","filename":"BUILDING","slug":"building","name":"BUILDING"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/CHANGELOG.md","relativePath":"CHANGELOG.md","relativeDir":"","filename":"CHANGELOG","slug":"changelog","name":"CHANGELOG"},{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/USER_GUIDE.md","relativePath":"USER_GUIDE.md","relativeDir":"","filename":"USER_GUIDE","slug":"user-guide","name":"USER GUIDE"}],"navTree":{"_files":[{"name":"README","slug":"readme","path":"README.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/README.md","isIndex":true},{"name":"API REFERENCE","slug":"api-reference","path":"API_REFERENCE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","isIndex":false},{"name":"ARCHITECTURE","slug":"architecture","path":"ARCHITECTURE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ARCHITECTURE.md","isIndex":false},{"name":"ATTRIBUTIONS","slug":"attributions","path":"ATTRIBUTIONS.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/ATTRIBUTIONS.md","isIndex":false},{"name":"BUILDING","slug":"building","path":"BUILDING.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/BUILDING.md","isIndex":false},{"name":"CHANGELOG","slug":"changelog","path":"CHANGELOG.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/CHANGELOG.md","isIndex":false},{"name":"USER GUIDE","slug":"user-guide","path":"USER_GUIDE.md","fullPath":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/USER_GUIDE.md","isIndex":false}]}},"docFile":{"path":"/home/megalith/AtariProjects/AtariFoundry/www/PROJECT_DOCS/crucible/API_REFERENCE.md","relativePath":"API_REFERENCE.md","relativeDir":"","filename":"API_REFERENCE","slug":"api-reference","name":"API REFERENCE","content":"# Crucible API Reference\n\n## Table of Contents\n\n1. [Overview](#overview)\n2. [Core Simulator API (sim65)](#core-simulator-api-sim65)\n3. [Atari BIOS API](#atari-bios-api)\n4. [ATR Filesystem API](#atr-filesystem-api)\n5. [Host Filesystem API](#host-filesystem-api)\n6. [SIO API](#sio-api)\n7. [Callback System](#callback-system)\n8. [Data Structures](#data-structures)\n\n## Overview\n\nThis document provides a complete reference for the crucible API. The API is organized into several modules:\n\n- **sim65**: Core 6502 CPU simulator\n- **atari**: Atari BIOS emulation\n- **atrfs**: ATR filesystem access\n- **athost**: Host filesystem device\n- **atsio**: SIO and ATR image access\n\n## Core Simulator API (sim65)\n\n### Simulator Creation and Management\n\n#### `sim65 sim65_new(void)`\n\nCreates a new simulator instance.\n\n**Returns**: Simulator handle, or NULL on error\n\n**Example**:\n```c\nsim65 s = sim65_new();\nif (!s) {\n    fprintf(stderr, \"Failed to create simulator\\n\");\n    exit(1);\n}\n```\n\n#### `void sim65_free(sim65 s)`\n\nFrees a simulator instance and all associated memory.\n\n**Parameters**:\n- `s`: Simulator handle\n\n### Memory Management\n\n#### `void sim65_add_ram(sim65 s, unsigned addr, unsigned len)`\n\nAdds an uninitialized RAM region.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Length in bytes\n\n#### `void sim65_add_zeroed_ram(sim65 s, unsigned addr, unsigned len)`\n\nAdds a zeroed RAM region.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Length in bytes\n\n#### `void sim65_add_data_ram(sim65 s, unsigned addr, const unsigned char *data, unsigned len)`\n\nAdds a RAM region initialized with data.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `data`: Initial data\n- `len`: Length in bytes\n\n#### `void sim65_add_data_rom(sim65 s, unsigned addr, const unsigned char *data, unsigned len)`\n\nAdds a ROM region (read-only).\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `data`: ROM data\n- `len`: Length in bytes\n\n#### `unsigned sim65_get_byte(sim65 s, unsigned addr)`\n\nReads a byte from memory.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Memory address\n\n**Returns**: Byte value, or 0x100 if invalid/uninitialized\n\n### Execution Control\n\n#### `enum sim65_error sim65_run(sim65 s, struct sim65_reg *regs, unsigned addr)`\n\nRuns the simulation from the given address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Initial register values (NULL for zero)\n- `addr`: Starting address\n\n**Returns**: Error code (0 = success)\n\n**Example**:\n```c\nstruct sim65_reg regs = {0};\nregs.pc = 0x0600;\nenum sim65_error err = sim65_run(s, \u0026regs, 0x0600);\n```\n\n#### `enum sim65_error sim65_call(sim65 s, struct sim65_reg *regs, unsigned addr)`\n\nCalls a subroutine via JSR and returns on RTS.\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Register values (NULL for zero)\n- `addr`: Subroutine address\n\n**Returns**: Error code (0 = success, `sim65_err_call_ret` = normal return)\n\n### Callbacks\n\n#### `void sim65_add_callback(sim65 s, unsigned addr, sim65_callback cb, enum sim65_cb_type type)`\n\nAdds a callback at a specific address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Address for callback\n- `cb`: Callback function\n- `type`: Callback type (read, write, or exec)\n\n**Callback Types**:\n- `sim65_cb_read`: Memory read callback\n- `sim65_cb_write`: Memory write callback\n- `sim65_cb_exec`: Instruction execution callback\n\n#### `void sim65_add_callback_range(sim65 s, unsigned addr, unsigned len, sim65_callback cb, enum sim65_cb_type type)`\n\nAdds callbacks for an address range.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Starting address\n- `len`: Range length\n- `cb`: Callback function\n- `type`: Callback type\n\n### Debugging and Tracing\n\n#### `void sim65_set_debug(sim65 s, enum sim65_debug level)`\n\nSets debug output level.\n\n**Parameters**:\n- `s`: Simulator handle\n- `level`: Debug level (`sim65_debug_none`, `sim65_debug_messages`, `sim65_debug_trace`)\n\n#### `void sim65_set_trace_file(sim65 s, FILE *f)`\n\nSets trace output file.\n\n**Parameters**:\n- `s`: Simulator handle\n- `f`: File handle (NULL for stderr)\n\n#### `void sim65_set_error_level(sim65 s, enum sim65_error_lvl level)`\n\nSets error reporting level.\n\n**Parameters**:\n- `s`: Simulator handle\n- `level`: Error level (`sim65_errlvl_none`, `sim65_errlvl_memory`, `sim65_errlvl_full`)\n\n#### `int sim65_dprintf(sim65 s, const char *format, ...)`\n\nPrints debug message (if debug enabled).\n\n**Parameters**:\n- `s`: Simulator handle\n- `format`: printf-style format string\n- `...`: Format arguments\n\n#### `int sim65_eprintf(sim65 s, const char *format, ...)`\n\nPrints error message (always).\n\n**Parameters**:\n- `s`: Simulator handle\n- `format`: printf-style format string\n- `...`: Format arguments\n\n### Profiling\n\n#### `void sim65_set_profiling(sim65 s, int enable)`\n\nEnables or disables profiling.\n\n**Parameters**:\n- `s`: Simulator handle\n- `enable`: Non-zero to enable\n\n#### `struct sim65_profile sim65_get_profile_info(sim65 s)`\n\nGets profiling information.\n\n**Returns**: Profile structure with cycle counts and statistics\n\n### Utility Functions\n\n#### `void sim65_set_flags(sim65 s, uint8_t flag, uint8_t val)`\n\nSets or clears processor flags.\n\n**Parameters**:\n- `s`: Simulator handle\n- `flag`: Flag mask (SIM65_FLAG_C, SIM65_FLAG_Z, etc.)\n- `val`: Value (0 = clear, non-zero = set)\n\n#### `void sim65_set_cycle_limit(sim65 s, uint64_t limit)`\n\nSets cycle execution limit.\n\n**Parameters**:\n- `s`: Simulator handle\n- `limit`: Maximum cycles (0 = unlimited)\n\n#### `void sim65_print_reg(const sim65 s, FILE *f)`\n\nPrints current register values.\n\n**Parameters**:\n- `s`: Simulator handle\n- `f`: Output file\n\n#### `const char *sim65_error_str(sim65 s, enum sim65_error e)`\n\nGets error message string.\n\n**Parameters**:\n- `s`: Simulator handle\n- `e`: Error code\n\n**Returns**: Error message string\n\n## Atari BIOS API\n\n### Initialization\n\n#### `void atari_init(sim65 s, emu_options *opts)`\n\nInitializes Atari BIOS emulation.\n\n**Parameters**:\n- `s`: Simulator handle\n- `opts`: Emulation options (NULL for defaults)\n\n**Options Structure**:\n```c\ntypedef struct {\n    int (*get_char)(void);  // Character input callback\n    void (*put_char)(int);  // Character output callback\n    int flags;              // Option flags\n} emu_options;\n```\n\n**Option Flags**:\n- `atari_opt_no_dos`: Skip DOS emulation\n- `atari_opt_pal`: PAL timing (50Hz)\n- `atari_opt_cycletime`: Cycle-based timing\n- `atari_opt_atari_mathpack`: Use original Atari math pack\n\n#### `int atari_add_option(emu_options *opt, const char *str)`\n\nParses option string and updates options.\n\n**Parameters**:\n- `opt`: Options structure\n- `str`: Option string (e.g., \"pal,fastmath\")\n\n**Returns**: 0 on success, non-zero on error\n\n### File Loading\n\n#### `enum sim65_error atari_xex_load(sim65 s, const char *name, int check)`\n\nLoads and runs a XEX file.\n\n**Parameters**:\n- `s`: Simulator handle\n- `name`: XEX filename\n- `check`: Non-zero to validate format\n\n**Returns**: Error code\n\n#### `enum sim65_error atari_rom_load(sim65 s, int addr, const char *name)`\n\nLoads a ROM file at the given address.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Load address\n- `name`: ROM filename\n\n**Returns**: Error code\n\n#### `int atari_load_image(sim65 s, const char *file_name)`\n\nLoads an ATR disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `file_name`: ATR filename\n\n**Returns**: 0 on success, non-zero on error\n\n#### `enum sim65_error atari_boot_image(sim65 s)`\n\nBoots from a loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Error code\n\n### DOS Configuration\n\n#### `void atari_dos_set_root(sim65 s, const char *path)`\n\nSets root path for D: device.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: Root directory path (NULL for current directory)\n\n#### `void atari_dos_add_cmdline(sim65 s, const char *cmd)`\n\nAdds command-line argument to DOS.\n\n**Parameters**:\n- `s`: Simulator handle\n- `cmd`: Command-line string\n\n### Utility Functions\n\n#### `void add_rts_callback(sim65 s, unsigned addr, unsigned len, sim65_callback cb)`\n\nInstalls callback with RTS instruction.\n\n**Parameters**:\n- `s`: Simulator handle\n- `addr`: Callback address\n- `len`: Range length\n- `cb`: Callback function\n\n#### `int atari_get_flags(sim65 s)`\n\nGets current emulation flags.\n\n**Returns**: Flags value\n\n## ATR Filesystem API\n\n### File Operations\n\n#### `int atrfs_find_file(sim65 s, const char *path, struct atr_dir_entry *entry)`\n\nFinds a file in the ATR filesystem.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: File path (e.g., \"FILE.EXT\" or \"DIR\\FILE.EXT\")\n- `entry`: Output directory entry\n\n**Returns**: 0 on success, -1 on error\n\n**Example**:\n```c\nstruct atr_dir_entry entry;\nif (atrfs_find_file(s, \"MYFILE.TXT\", \u0026entry) == 0) {\n    printf(\"Found file: %s\\n\", entry.filename);\n}\n```\n\n#### `struct atr_file_handle *atrfs_open_file(sim65 s, uint16_t start_sector, uint32_t size)`\n\nOpens a file handle for reading.\n\n**Parameters**:\n- `s`: Simulator handle\n- `start_sector`: Starting sector number\n- `size`: File size in bytes\n\n**Returns**: File handle, or NULL on error\n\n#### `int atrfs_read_byte(struct atr_file_handle *fh)`\n\nReads a byte from file.\n\n**Parameters**:\n- `fh`: File handle\n\n**Returns**: Byte value, or -1 on EOF/error\n\n#### `int atrfs_seek(struct atr_file_handle *fh, uint32_t position)`\n\nSeeks to position in file.\n\n**Parameters**:\n- `fh`: File handle\n- `position`: Byte position\n\n**Returns**: 0 on success, -1 on error\n\n#### `void atrfs_close_file(struct atr_file_handle *fh)`\n\nCloses and frees file handle.\n\n**Parameters**:\n- `fh`: File handle\n\n### Directory Operations\n\n#### `int atrfs_read_directory(sim65 s, uint16_t dir_sector, struct atr_dir_entry *entries, int max_entries)`\n\nReads directory entries.\n\n**Parameters**:\n- `s`: Simulator handle\n- `dir_sector`: Directory sector number\n- `entries`: Output array\n- `max_entries`: Maximum entries to read\n\n**Returns**: Number of entries read, or -1 on error\n\n## Host Filesystem API\n\n### Initialization\n\n#### `void atari_host_init(sim65 s)`\n\nInitializes H: device handler.\n\n**Parameters**:\n- `s`: Simulator handle\n\n#### `void atari_host_set_root(sim65 s, const char *path)`\n\nSets root path for H: device.\n\n**Parameters**:\n- `s`: Simulator handle\n- `path`: Root directory path (NULL for current directory)\n\n**Example**:\n```c\natari_host_init(s);\natari_host_set_root(s, \"/home/user/atari_files\");\n```\n\n## SIO API\n\n### Initialization\n\n#### `void atari_sio_init(sim65 s)`\n\nInitializes SIO emulation.\n\n**Parameters**:\n- `s`: Simulator handle\n\n### Disk Image Operations\n\n#### `int atari_sio_load_image(sim65 s, const char *file_name)`\n\nLoads an ATR disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `file_name`: ATR filename\n\n**Returns**: 0 on success, non-zero on error\n\n#### `enum sim65_error atari_sio_boot(sim65 s)`\n\nBoots from loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Error code\n\n### ATR Access\n\n#### `const struct atr_disk_image *atari_sio_get_disk_image(sim65 s)`\n\nGets pointer to loaded disk image.\n\n**Parameters**:\n- `s`: Simulator handle\n\n**Returns**: Disk image structure, or NULL if not loaded\n\n#### `int atari_sio_read_sector(sim65 s, unsigned sector, uint8_t *buffer, unsigned *size)`\n\nReads a sector from ATR image.\n\n**Parameters**:\n- `s`: Simulator handle\n- `sector`: Sector number (1-based)\n- `buffer`: Output buffer\n- `size`: Input/output buffer size\n\n**Returns**: 0 on success, non-zero on error\n\n## Callback System\n\n### Callback Function Signature\n\n```c\ntypedef int (*sim65_callback)(sim65 s, struct sim65_reg *regs, \n                               unsigned addr, int data);\n```\n\n**Parameters**:\n- `s`: Simulator handle\n- `regs`: Register values before instruction\n- `addr`: Address causing callback\n- `data`: \n  - For read callbacks: unused\n  - For write callbacks: value being written\n  - For exec callbacks: `sim65_cb_exec`\n\n**Returns**:\n- For read callbacks: byte value (0-255)\n- For other callbacks: error code (0 = success, negative = error)\n\n### Example Callback\n\n```c\nstatic int my_callback(sim65 s, struct sim65_reg *regs, \n                       unsigned addr, int data)\n{\n    if (data == sim65_cb_exec) {\n        // Instruction execution callback\n        sim65_dprintf(s, \"Executing at $%04X\\n\", addr);\n        // Simulate RTS if needed\n        return 0;\n    }\n    return 0;\n}\n\n// Register callback\nsim65_add_callback(s, 0xE456, my_callback, sim65_cb_exec);\n```\n\n## Data Structures\n\n### `struct sim65_reg`\n\nCPU register values.\n\n```c\nstruct sim65_reg {\n    uint16_t pc;  // Program counter\n    uint8_t a;    // Accumulator\n    uint8_t x;    // X register\n    uint8_t y;    // Y register\n    uint8_t p;    // Processor status\n    uint8_t s;    // Stack pointer\n};\n```\n\n### `struct atr_file_handle`\n\nATR file handle.\n\n```c\nstruct atr_file_handle {\n    uint16_t start_sector;\n    uint16_t current_sector;\n    uint32_t file_size;\n    uint32_t position;\n    uint8_t sector_buffer[256];\n    int sector_pos;\n    int sector_size;\n    sim65 sim;\n};\n```\n\n### `struct atr_dir_entry`\n\nATR directory entry.\n\n```c\nstruct atr_dir_entry {\n    uint8_t flags;\n    uint16_t start_sector;\n    uint16_t sector_count;\n    uint32_t byte_count;\n    char filename[12];\n    uint8_t attributes;\n    int is_hidden;\n    int is_protected;\n    int is_archived;\n};\n```\n\n### `struct atr_disk_image`\n\nATR disk image structure.\n\n```c\nstruct atr_disk_image {\n    uint8_t *data;\n    unsigned sec_size;\n    unsigned sec_count;\n};\n```\n\n### `enum sim65_error`\n\nError codes.\n\n```c\nenum sim65_error {\n    sim65_err_none = 0,\n    sim65_err_exec_undef = -1,\n    sim65_err_exec_uninit = -2,\n    sim65_err_read_undef = -3,\n    sim65_err_read_uninit = -4,\n    sim65_err_write_undef = -5,\n    sim65_err_write_rom = -6,\n    sim65_err_break = -7,\n    sim65_err_invalid_ins = -8,\n    sim65_err_call_ret = -9,\n    sim65_err_cycle_limit = -10,\n    sim65_err_user = -11\n};\n```\n\n## Error Handling\n\nAll functions that can fail return error codes. Check return values:\n\n```c\nenum sim65_error err = atari_xex_load(s, \"program.xex\", 1);\nif (err != sim65_err_none) {\n    fprintf(stderr, \"Error: %s\\n\", sim65_error_str(s, err));\n}\n```\n\n## Memory Management\n\n- Simulator handles memory allocation internally\n- File handles must be closed with `atrfs_close_file()`\n- Simulator instance must be freed with `sim65_free()`\n\n## Thread Safety\n\nThe API is **not** thread-safe. Use one simulator instance per thread.\n\n## See Also\n\n- [User Guide](USER_GUIDE.md) - Usage examples\n- [Architecture](ARCHITECTURE.md) - System design\n- [Building Guide](BUILDING.md) - Build instructions\n"},"currentPath":"api-reference"},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["crucible","api-reference"]},"buildId":"CnF04P5ob_bUVxETgw2P_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>